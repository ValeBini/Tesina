\chapter{Formalización de Mónadas Concurrentes en Agda}\label{chapter:form} 

Formalizar la matemática consiste en representar las estructuras y pruebas matemáticas en un sistema axiomático formal de manera que la correctitud de dichas pruebas pueda ser verificada mecánicamente. Esto quiere decir que el proceso de verificación es algorítmico y puede ser realizado por una computadora sin recurrir a la creatividad o la intuición. El proceso de formalización es complejo y no puede realizarse \textit{a mano}, sino que requiere de herramientas especializadas tales como asistentes de pruebas para llevarse a cabo. 

Como se mencionó anteriormente, Agda es, además de un lenguaje de programación funcional con tipos dependientes, un asistente de pruebas. Por el isomorfismo de Curry-Howard, se pueden representar proposiciones lógicas mediante tipos. Una proposición se demuestra escribiendo un programa del tipo correspondiente. Cuando se formaliza una estructura algebraica en Agda, lo que se hace es definir un tipo que la represente. De esta manera, al generar un habitante de dicho tipo, se genera una instancia de la estructura algebraica representada. 

En este capítulo se mostrará el modo de formalizar estructuras algebraicas en Agda comenzando con un ejemplo simple: los monoides. Luego se agregará complejidad mostrando formalizaciones a nivel de funtores y mónadas, al igual que se fue escalando en los capítulos anteriores. Finalmente, se dará la formalización de los monoides y mónadas concurrentes.

\section{Formalización de monoides}\label{form:monoids}

Como se introdujo en la definición \ref{def:monoid}, un monoide consiste en un conjunto junto con una operación binaria asociativa tal que en el conjunto exista un elemento que actúe como neutro respecto de la operación. En Agda, se formaliza este concepto definiendo un tipo \textit{record} que lo representa. No hay una única forma de definir este tipo, por lo que al hacerlo se tomaron varias decisiones. A continuación se muestra cómo quedó la última versión de esta definición y se explican las principales decisiones tomadas junto con el significado y propósito de cada uno de los campos. 

\ExecuteMetaData[latex/Structures.tex]{monoid}

Como se puede observar, el \textit{record} \AgdaRecord{Monoid} tiene un parámetro \AgdaBound{M} de tipo \AgdaPrimitiveType{Set}. Este representa el conjunto soporte del monoide. Se podría discutir si este debería ser un parámetro o un campo del \textit{record} pero, como indica Norell en su tesis \cite{norell:thesis}, es más fácil convertir un parámetro en un campo que al revés, por lo que en general se pone como parámetro a menos que se necesite que sea un campo por alguna razón.

Los \textit{records} son una especie de tupla en la cual cada campo puede depender de todos los anteriores. Esto hace que el orden en que se introducen los campos no pueda ser arbitrario. 

El primer campo que aparece es \AgdaField{$\_\cong_m\_$}, el cual es una función que toma dos argumentos de tipo \AgdaBound{M} y devuelve un elemento de tipo \AgdaPrimitiveType{Set}. Este campo es una relación binaria entre elementos del conjunto \AgdaBound{M} y, como se indica en el segundo campo, debe ser una relación de equivalencia. En efecto, el campo \AgdaField{eq$_m$} es una prueba de que la relación \AgdaField{$\_\cong_m\_$} es una relación de equivalencia, es decir, que es reflexiva, simétrica y transitiva. Esto se prueba dando una instancia del \textit{record} \AgdaRecord{IsEquivalence} provisto por la librería \AgdaModule{Relation.Binary.Structures}. La razón de que se pidan estos dos campos es que para los siguientes se requiere una noción de igualdad, ya que algunos de ellos son ecuaciones entre elementos del conjunto \AgdaBound{M} que deben cumplirse para que tal conjunto sea un monoide. La noción de igualdad tradicional (igualdad proposicional en Agda) no siempre es suficiente ya que, como se vio en la sección \ref{delay:delay}, a veces nos interesan otros tipos de equivalencias como, por ejemplo, la bisemejanza en el caso del tipo \textit{delay}. Esto sucede con frecuencia cuando se trabaja con tipos coinductivos ya que una prueba de igualdad tradicional en general sería infinita. Es por esto que se decidió, tanto para esta como para las estructuras que siguen, que la noción de igualdad sea un campo, de manera que puedan definirse las estructuras con diferentes nociones de igualdad según sea conveniente. 

El tercer campo, \AgdaField{zero$_m$}, es un elemento particular del conjunto \AgdaBound{M}, el cual será el elemento neutro de la operación binaria. Esta última se introduce en el cuarto campo, \AgdaField{$\_+_m\_$}, como una función que toma dos elementos de \AgdaBound{M} y devuelve un nuevo elemento del mismo conjunto. 

Los últimos tres campos son los más interesantes y son los que hacen que, al dar un habitante del tipo \AgdaRecord{Monoid}, quede demostrado que tal habitante es efectivamente un monoide. El primero de ellos, \AgdaField{idl}, representa la prueba de que \AgdaField{zero$_m$} es un neutro a izquierda respecto de la operación \AgdaField{$+_m$}. El tipo de este campo representa una proposición que indica que para todo elemento \AgdaBound{x : M}, se cumple la ecuación \hbox{\AgdaSymbol{(}\AgdaField{zero$_m$} \AgdaField{$+_m$} \AgdaBound{x}\AgdaSymbol{)} \AgdaField{$\cong_m$} \AgdaBound{x}}. El siguiente, \AgdaField{idr}, es análogo a \AgdaField{idl} y representa la prueba de que \AgdaField{zero$_m$} es neutro a derecha respecto de la operación \AgdaField{$+_m$}. Por último, \AgdaField{assoc} representa la prueba de que la operación \AgdaField{$+_m$} es asociativa. Esto es, para cualesquiera elementos dados \AgdaBound{x}, \AgdaBound{y} y \AgdaBound{z} del conjunto \AgdaBound{M}, se cumple que \AgdaSymbol{(}\AgdaBound{x} \AgdaField{$+_m$} \AgdaSymbol{(}\AgdaBound{y} \AgdaField{$+_m$} \AgdaBound{z}\AgdaSymbol{))} \AgdaField{$\cong_m$} \AgdaSymbol{((}\AgdaBound{x} \AgdaField{$+_m$} \AgdaBound{y}\AgdaSymbol) \AgdaField{$+_m$} \AgdaBound{z}\AgdaSymbol{)}. Estas pruebas se dan en torno a la noción de igualdad introducida en el primer campo.