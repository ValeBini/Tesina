\chapter{Formalización de Mónadas Concurrentes en Agda}\label{chapter:form} 

Formalizar la matemática consiste en representar las estructuras y pruebas matemáticas en un sistema axiomático formal de manera que la correctitud de dichas pruebas pueda ser verificada mecánicamente. Esto quiere decir que el proceso de verificación es algorítmico y puede ser realizado por una computadora sin recurrir a la creatividad o la intuición. El proceso de formalización es complejo, es por esto que existen herramientas especializadas tales como asistentes de pruebas para llevarlo a cabo de manera más simple y práctica. 

Como se mencionó anteriormente, Agda es, además de un lenguaje de programación funcional con tipos dependientes, un asistente de pruebas. Por el isomorfismo de Curry-Howard, se pueden representar proposiciones lógicas mediante tipos. Una proposición se demuestra escribiendo un programa del tipo correspondiente. Cuando se formaliza una estructura algebraica en Agda, lo que se hace es definir un tipo que la represente. De esta manera, al generar un habitante de dicho tipo, se genera una instancia de la estructura algebraica representada. 

En este capítulo se mostrará el modo de formalizar estructuras algebraicas en Agda comenzando con un ejemplo simple: los monoides. Luego se agregará complejidad mostrando formalizaciones a nivel de funtores y mónadas, al igual que se fue escalando en los capítulos anteriores. Finalmente, se dará la formalización de los monoides y mónadas concurrentes.

\section{Formalización en Agda: los monoides}\label{form:monoids}

Como se introdujo en la definición \ref{def:monoid}, un monoide consiste en un conjunto junto con una operación binaria asociativa tal que en el conjunto exista un elemento que actúe como neutro respecto de la operación. En Agda, se formaliza este concepto definiendo un tipo \AgdaKeyword{record} que lo representa. No hay una única forma de definir este tipo, por lo que al hacerlo se tomaron varias decisiones. A continuación se muestra cómo quedó la última versión de esta definición y se explican las principales decisiones tomadas junto con el significado y propósito de cada uno de los campos. 

\ExecuteMetaData[latex/Structures/Monoid.tex]{monoid}

Como se puede observar, el \AgdaKeyword{record} \AgdaRecord{Monoid} tiene un parámetro \AgdaBound{M} de tipo \AgdaPrimitiveType{Set}. Este representa el conjunto soporte del monoide. Se podría discutir si este debería ser un parámetro o un campo del \AgdaKeyword{record} pero, como indica Norell en su tesis \cite{norell:thesis}, es más fácil convertir un parámetro en un campo que al revés, por lo que en general se pone como parámetro a menos que se necesite que sea un campo por alguna razón.

El primer campo que aparece es \AgdaField{$\_\cong_m\_$}, el cual es una función que toma dos argumentos de tipo \AgdaBound{M} y devuelve un elemento de tipo \AgdaPrimitiveType{Set}. Este campo es una relación binaria entre elementos del conjunto \AgdaBound{M} y, como se indica en el segundo campo, debe ser una relación de equivalencia. En efecto, el campo \AgdaField{eq$_m$} es una prueba de que la relación \AgdaField{$\_\cong_m\_$} es una relación de equivalencia, es decir que es reflexiva, simétrica y transitiva. Esto se prueba dando una instancia del \AgdaKeyword{record} \AgdaRecord{IsEquivalence} provisto por la librería  \href{https://agda.github.io/agda-stdlib/Relation.Binary.Structures.html}{\AgdaModule{Relation.Binary.Structures}}. La razón de que se pidan estos dos campos es que para los siguientes se requiere una noción de igualdad, ya que algunos de ellos son ecuaciones entre elementos del conjunto \AgdaBound{M} que deben cumplirse para que tal conjunto sea un monoide. La noción de igualdad tradicional (igualdad proposicional en Agda) no siempre es suficiente ya que, como se vio en la sección \ref{delay:delay}, a veces nos interesan otros tipos de equivalencias como, por ejemplo, la bisemejanza en el caso del tipo \textit{delay}. Esto sucede con frecuencia cuando se trabaja con tipos coinductivos ya que una prueba de igualdad tradicional en general sería infinita. Es por esto que se decidió, tanto para esta como para las estructuras que siguen, que la noción de igualdad sea un campo, de manera que puedan definirse las estructuras con diferentes nociones de igualdad según sea conveniente. 

El tercer campo, \AgdaField{zero$_m$}, es un elemento particular del conjunto \AgdaBound{M}, el cual será el elemento neutro de la operación binaria. Esta última se introduce en el cuarto campo, \AgdaField{$\_+_m\_$}, como una función que toma dos elementos de \AgdaBound{M} y devuelve un nuevo elemento del mismo conjunto. 

Los últimos tres campos son los más interesantes y son los que hacen que, al dar un habitante del tipo \AgdaRecord{Monoid}, quede demostrado que tal habitante es efectivamente un monoide. El primero de ellos, \AgdaField{idl}, representa la prueba de que \AgdaField{zero$_m$} es un neutro a izquierda respecto de la operación \AgdaField{$+_m$}. El tipo de este campo representa una proposición que indica que para todo elemento \AgdaBound{x : M}, se cumple la ecuación \hbox{\AgdaSymbol{(}\AgdaField{zero$_m$} \AgdaField{$+_m$} \AgdaBound{x}\AgdaSymbol{)} \AgdaField{$\cong_m$} \AgdaBound{x}}. El siguiente, \AgdaField{idr}, es análogo a \AgdaField{idl} y representa la prueba de que \AgdaField{zero$_m$} es neutro a derecha respecto de la operación \AgdaField{$+_m$}. Por último, \AgdaField{assoc} representa la prueba de que la operación \AgdaField{$+_m$} es asociativa. Esto es, para cualesquiera elementos dados \AgdaBound{x}, \AgdaBound{y} y \AgdaBound{z} del conjunto \AgdaBound{M}, se cumple que \AgdaSymbol{(}\AgdaBound{x} \AgdaField{$+_m$} \AgdaSymbol{(}\AgdaBound{y} \AgdaField{$+_m$} \AgdaBound{z}\AgdaSymbol{))} \AgdaField{$\cong_m$} \AgdaSymbol{((}\AgdaBound{x} \AgdaField{$+_m$} \AgdaBound{y}\AgdaSymbol) \AgdaField{$+_m$} \AgdaBound{z}\AgdaSymbol{)}. Estas pruebas se dan en torno a la noción de igualdad introducida en el primer campo.

\section{Formalización a nivel de Funtores y Mónadas}\label{form:funtmon}

Siguiendo con el camino hacia la formalización de los monoides y mónadas concurrentes, se expondrán en esta sección las formalizaciones de las estructuras de funtor monoidal y mónada. La elección de estas estructuras se debe a que cada una de ellas aporta un ingrediente que luego aparecerá en la formalización de las mónadas concurrentes. La formalización de mónadas, por su parte, agrega la estructura monádica, \textit{bind} y \textit{return}, junto con las leyes de mónada. Por otro lado, el funtor monoidal introduce la operación \textit{merge} y sus propiedades, que también aparecen en la formalización de mónadas concurrentes puesto que, como se expone en la definición \ref{def:monconc}, estas son mónadas cuyo funtor subyacente tiene una estructura monoidal.

\subsection{Formalización de Mónada}\label{funtmon:mon}

La formalización de las mónadas está dada, al igual que la de los monoides, por un \AgdaKeyword{record} parametrizado. Sin embargo, en este caso el parámetro no es simplemente un conjunto sino que se trata de un funtor \AgdaBound{M} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaSymbol{$\rightarrow$} \AgdaPrimitiveType{Set}. 
%En el siguiente bloque de código se muestra la definición del \AgdaKeyword{record} \AgdaRecord{Monad}. 

\ExecuteMetaData[latex/Structures/Monad.tex]{monad}

Como se adelantó en la sección anterior, el primer campo de esta definición es una noción de igualdad. A diferencia de la que se pedía en \AgdaRecord{Monoid}, esta debe estar definida para elementos del conjunto \AgdaBound{M A}, para cualquier \AgdaBound{A}. De igual manera, la prueba de que esta relación es de equivalencia debe darse para un \AgdaBound{A} arbitrario. La arbitrariedad de \AgdaBound{A} se debe a que, como se puede ver en los siguientes campos, el funtor \AgdaBound{M} se aplica sobre diversos conjuntos y se necesita la igualdad definida para todos los conjuntos sobre los que \AgdaBound{M} se aplique. Esta necesidad se evidencia sobre todo al dar instancias de \AgdaRecord{Monad}.

El tercer campo es la función \AgdaField{return} usual de las mónadas. Esta toma un elemento de algún conjunto \AgdaBound{A} arbitrario y lo encapsula en la mónada aplicando el funtor \AgdaBound{M}. En la definición formal de las mónadas (ambas versiones) esta función representa el morfismo $\eta : A \rightarrow \mathit{M} A$. El campo que sigue, \AgdaField{$\_\gg=\_$}, representa el operador \textit{bind} de mónadas que toma un elemento de \AgdaBound{M A} y una función que toma el resultado \AgdaBound{A} y genera un elemento de \AgdaBound{M B} y devuelve un \AgdaBound{M B}. Esta función representa la secuenciación de computaciones y está definida en el estilo de la definición de mónadas como sistemas de extensión. En la definición \ref{def:sistext} se define el operador $\_^*$ que toma una función de tipo $A \rightarrow \mathit{M} B$ y devuelve una funcióń de tipo $\mathit{M} A \rightarrow \mathit{M} B$. El tipo del operador es por tanto $\_^* : (A \rightarrow \mathit{M} B) \rightarrow \mathit{M} A \rightarrow \mathit{M} B$. Si se da vuelta el orden de sus argumentos se obtiene el tipo de la función \textit{bind}: \AgdaField{$\_\gg=\_$} \AgdaSymbol{:} \AgdaBound{M A} \AgdaSymbol{$\rightarrow$} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{$\rightarrow$} \AgdaBound{M B}\AgdaSymbol{) $\rightarrow$} \AgdaBound{M B}. 

Los últimos tres campos representan las leyes de mónadas. Estos están dados por tipos que representan proposiciones. El primero de ellos, \AgdaField{law$_1$}, representa la primera ley de mónadas que dice que para cualquier elemento \AgdaBound{x} de un conjunto \AgdaBound{A} y cualquier función \AgdaBound{f} que dado un elemento de \AgdaBound{A} y genere una computación de tipo \AgdaBound{M B}, se debe cumplir que hacer el \textit{bind} de \AgdaField{return} \AgdaBound{x} con \AgdaBound{f} debe dar el mismo resultado que aplicar \AgdaBound{f} a \AgdaBound{x}. Esta ley se corresponde con la siguiente ecuación de la definición formal: $f^* \circ \eta_A = f$. Cuando se da una instancia de \AgdaRecord{Monad} y se asigna al campo \AgdaField{law$_1$} un habitante de este tipo, se está demostrando que las expresiones asignadas a los campos \AgdaField{return} y \AgdaField{$\_\gg=\_$} cumplen con la primera ley de mónadas respecto de la igualdad provista por el primer campo del \AgdaKeyword{record}.

De la misma manera, \AgdaField{law$_2$} representa la proposición que indica que se cumple la segunda ley de mónadas. Esta postula que dada una computación \AgdaBound{t} de tipo \AgdaBound{M A}, hacer \textit{bind} de \AgdaBound{t} con \AgdaField{return} es lo mismo que aplicar sólo \AgdaBound{t}. Esta segunda ley se corresponde con la ecuación que indica que $\eta_A^* = id_{M A}$. El término $\eta_A^*$ corresponde a la acción de aplicar a alguna computación \AgdaBound{t} el operador \textit{bind} seguido de \AgdaField{return}, mientras que del otro lado se tiene $id_{M A}$ que aplicado a alguna computación arbitraria \AgdaBound{t} da como resultado \AgdaBound{t}.

Finalmente, el último campo, \AgdaField{law$_3$}, representa la asociatividad del operador \hbox{\AgdaField{$\_\gg=\_$}}. Esta denota que, dadas una computación \AgdaBound{t} de tipo \AgdaBound{M A} y dos funciones \AgdaBound{f} y \AgdaBound{g} que van de \AgdaBound{A} en \hbox{\AgdaBound{M B}} y de \AgdaBound{B} en \AgdaBound{M C} respectivamente, es lo mismo aplicar el \textit{bind} a \AgdaBound{t} con \AgdaBound{f} y luego al resultado obtenido aplicarle el \textit{bind} con \AgdaBound{g}, que aplicarlo a \AgdaBound{t} con la función que toma un \AgdaBound{x} de tipo \AgdaBound{A} y devuelve la aplicación de \AgdaBound{f x} \AgdaField{$\gg=$} \AgdaBound{g}. Esta última ley se corresponde con la ecuación que indica que $g^* \circ f^* = (g^* \circ f)^*$. 

\subsection{Formalización de Funtor Monoidal}\label{funtmon:funt}

Como se indica en la definición \ref{def:monoidalfuntor}, un funtor monoidal es un funtor que cuenta con una estructura monoidal de manera que se cumplen ciertas ecuaciones de congruencia. Su formalización queda definida como un \AgdaKeyword{record} que, al igual que \AgdaRecord{Monad}, está parametrizado por un funtor \AgdaBound{M} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaSymbol{$\rightarrow$} \AgdaPrimitiveType{Set}. 

\ExecuteMetaData[latex/Structures/MonoidalFunctor.tex]{monoidal}

Los primeros dos campos del \AgdaKeyword{record} son iguales a los de \AgdaRecord{Monad} y brindan la noción de igualdad junto con la prueba de que tal noción es una relación de equivalencia. 

Los dos campos que siguen conforman la estructura monoidal que el funtor requiere para ser un funtor monoidal. La transformación natural $m : \mathit{M} A \times \mathit{M} B \rightarrow \mathit{M} (A \times B)$ está dada por el campo \AgdaField{merge}. A diferencia de como se describe en la definición formal (\ref{def:monoidalfuntor}), en este caso \AgdaField{merge} no toma un elemento de \AgdaBound{M A} $\times$ \AgdaBound{M B}, sino que toma ambos elementos por separado, es decir que se encuentra currificada. 

El otro ingrediente que se necesita para dar la estructura monoidal del funtor es el morfismo $e : \mathbf{1} \rightarrow \mathit{M} \mathbf{1}$. En la sección \ref{monadas:cartesian} se mencionó que en esta tesina se trabajaría siempre con la categoría \textbf{Set} considerando como objeto terminal el conjunto unitario $\mathbf{1} = \{\star\}$. Este conjunto tiene una representación propia en Agda y está dada por el tipo de dato \AgdaDatatype{$\top$} definido en el módulo \href{https://agda.github.io/agda-stdlib/Data.Unit.Base.html}{\AgdaModule{Data.Unit.Base}}. Este se define como un \AgdaKeyword{record} sin campos con un único constructor llamado \AgdaInductiveConstructor{tt}. En la formalización de funtor monoidal, en lugar de representar al morfistmo $e$ con una función de tipo \AgdaDatatype{$\top$} \AgdaSymbol{$\rightarrow$} \AgdaBound{M} \AgdaDatatype{$\top$}, este se representa directamente como un habitante del tipo \AgdaBound{M} \AgdaDatatype{$\top$} llamado \AgdaField{unit}. Esto es porque sólo hay un habitante de tipo \AgdaDatatype{$\top$}, por lo que sólo habrá un habitante del tipo \AgdaBound{M} \AgdaDatatype{$\top$} y darlo como función sería redundante, ya que siempre habría que escribir \AgdaField{unit} \AgdaInductiveConstructor{tt} puesto que no habría otro posible argumento para la función.

El siguiente campo de \AgdaRecord{MonoidalFunctor} es \AgdaField{fmap}. Como se describió en la definición \ref{def:funtor}, un funtor $\mathit{F}$ de $\mathscr{C}$ en $\mathscr{D}$ no sólo asigna un objeto de $\mathscr{D}$ a cada objeto de $\mathscr{C}$, sino que también asigna a cada morfismo $f : A \rightarrow B \in \text{\bf mor} \ \mathscr{C}$ un morfismo $\mathit{F}(f) : \mathit{F} A \rightarrow \mathit{F} B$. El parámetro \AgdaBound{M} sólo representa la asignación de objetos del funtor, asigna a cada objeto de \textbf{Set} otro objeto de \textbf{Set}. La asignación de morfismos no está definida. El rol de \AgdaField{fmap} es representar esta asignación, es decir que es un mapeo que, dada una función que va de \AgdaBound{A} en \AgdaBound{B}, devuelve otra función que va de \AgdaBound{M A} en \AgdaBound{M B}. Este campo es necesario para poder definir las ecuaciones que la estructura monoidal debe cumplir, las cuales están dadas en los últimos tres campos del \AgdaKeyword{record}.

Las primeras dos, \AgdaField{idr} e \AgdaField{idl}, son análogas puesto que representan las pruebas de que \AgdaField{unit} es neutro, a derecha e izquierda respectivamente, respecto de la operación \AgdaField{merge}. Por esta razón se explicará en profundidad sólo una de ellas, la elegida será \AgdaField{idr}. Volviendo a la definición formal, se muestra a continuación la ecuación correspondiente a \AgdaField{idr} junto con su versión vista como un diagrama conmutativo, el cual puede resultar más facil de comprender a la vista.
\begin{equation*}
\pi_1 = \mathit{F}(\pi_1) \circ m_{A,\mathbf{1}} \circ (id_{\mathit{F}A} \times e) 
\qquad 
\begin{tikzcd}[column sep = huge]
\mathit{F} A \times \mathbf{1} \arrow[d, "\pi_1"] \arrow[r, "id_{\mathit{F} A} \times e"] & \mathit{F} A \times \mathit{F} \mathbf{1} \arrow[d, "m_{A,\mathbf{1}}"]  \\
\mathit{F} A & \mathit{F} (A \times \mathbf{1}) \arrow[l, "\mathit{F}(\pi_1)"]
\end{tikzcd}
\end{equation*}

Teniendo en cuenta que ya no se tiene $e$ que pasa de $\mathbf{1}$ a $\mathit{F} \mathbf{1}$, sino que se tiene directamente un elemento de $\mathit{F} \mathbf{1}$, la esquina superior izquierda del diagrama desaparece, quedando como resultado el diagrama \ref{diagrama1}. Si luego se reemplaza $\mathit{F}$ por \AgdaBound{M}, $\mathbf{1}$ por \AgdaDatatype{$\top$} y $m_{A,\mathbf{1}}$ por \AgdaField{merge}, se obtiene el diagrama \ref{diagrama2}. 
\vspace{-1.25\baselineskip}

\begin{multicols}{2}
\begin{equation}\label{diagrama1}
\begin{tikzcd}[column sep = large]
& \mathit{F} A \times \mathit{F} \mathbf{1} \arrow[d, "m_{A,\mathbf{1}}"] \arrow[dl, "\pi_1"]  \\
\mathit{F} A & \mathit{F} (A \times \mathbf{1}) \arrow[l, "\mathit{F}(\pi_1)"]
\end{tikzcd}
\end{equation}

\begin{equation}\label{diagrama2}
\begin{tikzcd}[column sep = large]
& \AgdaBound{M} A \times \AgdaBound{M} \ \AgdaDatatype{$\top$} \arrow[d, "\AgdaField{merge}"] \arrow[dl, "\pi_1"]  \\
\AgdaBound{M} A & \AgdaBound{M} (A \times \AgdaDatatype{$\top$}) \arrow[l, "\AgdaBound{M}(\pi_1)"]
\end{tikzcd}
\end{equation}
\end{multicols}

El segundo diagrama da lugar a la ecuación: \AgdaBound{M}$(\pi_1) \ \circ$ \AgdaField{merge} \AgdaField{$\cong_m$} $\pi_1$. Si en lugar de utilizar $\pi_1$ se considera su inversa $\pi_1^{-1}$, el diagrama y su ecuación correspondiente pasan a quedar como sigue:
\vspace{-1.25\baselineskip}

\begin{multicols}{2}
\begin{equation}\label{diagrama3}
\begin{tikzcd}[column sep = large]
& \AgdaBound{M} A \times \AgdaBound{M} \ \AgdaDatatype{$\top$} \arrow[d, "\AgdaField{merge}"]  \\
\AgdaBound{M} A \arrow[ur, "\pi_1^{-1}"] \arrow{r}[below]{\AgdaBound{M}(\pi_1^{-1})} & \AgdaBound{M} (A \times \AgdaDatatype{$\top$}) 
\end{tikzcd}
\end{equation}

\vspace*{\fill}
\begin{equation}
\AgdaField{merge} \circ \pi_1^{-1} \ \ \AgdaField{$\cong_m$} \ \ \AgdaBound{M} (\pi_1^{-1}) 
\end{equation}
\vspace*{\fill}
\end{multicols}

Ahora, como en realidad \AgdaField{merge} no toma un producto cartesiano sino ambos elementos por separado, no es necesario utilizar $\pi_1^{-1}$ antes de \AgdaField{merge}. Si se considera por último que $\pi_1^{-1}$ se representa en Agda como \AgdaSymbol{($\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$ \ (}\AgdaBound{a} \AgdaInductiveConstructor{, \ tt}\AgdaSymbol{))} y que la asignación de morfismos del funtor $\mathit{M}$ está dada por el campo \AgdaField{fmap}, se obtiene finalmente la ecuación \AgdaField{merge} \AgdaField{$\cong_m$} \AgdaField{fmap} \AgdaSymbol{($\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$ \ (}\AgdaBound{a} \AgdaInductiveConstructor{, \ tt}\AgdaSymbol{))}, la cual al agregarle los argumentos correspondientes forma la ecuación del campo \AgdaField{idr}:  
\begin{equation*}
\AgdaSymbol{(}\AgdaField{merge} \ \AgdaBound{a} \ \AgdaField{unit}\AgdaSymbol{)} \   \AgdaField{$\cong_m$} \ \AgdaSymbol{(}\AgdaField{fmap} \AgdaSymbol{($\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$ \ (}\AgdaBound{a} \AgdaInductiveConstructor{, \ tt} \AgdaSymbol{))} \ \AgdaBound{a}\AgdaSymbol{)}.
\end{equation*}

Queda por analizar el campo \AgdaField{assoc}. Como su nombre lo indica, este representa la prueba de que la operación \AgdaField{merge} es asociativa. En la definición formal se requiere la siguiente ecuación en la cual $\alpha$ representa la asociatividad del producto cartesiano.
\begin{equation*}
\mathit{F}(\alpha) \circ m_{X \times Y, Z} \circ (m_{X,Y} \times id_{\mathit{F}Z}) = m_{X, Y \times Z} \circ (id_{\mathit{F}X} \times m_{Y,Z}) \circ \alpha
\end{equation*}
$\alpha$ se representa en Agda como la asignación \AgdaSymbol{($\lambda \{$((}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{c}\AgdaSymbol{) $\rightarrow$ (}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}\AgdaSymbol{))\})}. Luego $\mathit{F}(\alpha)$ en se escribe en Agda como: 
\AgdaSymbol{(}\AgdaField{fmap} \AgdaSymbol{($\lambda \{$((}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{c}\AgdaSymbol{) $\rightarrow$ (}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}\AgdaSymbol{))\}))} siguiendo la representación dada.

Por otro lado, $m_{X \times Y, Z} \circ (m_{X,Y} \times id_{\mathit{F}Z})$ se traduce  en la formalización propuesta aplicada a sus argumentos como \AgdaSymbol{(}\AgdaField{merge} \AgdaSymbol{(}\AgdaField{merge} \AgdaBound{a b}\AgdaSymbol{)} \AgdaBound{c}\AgdaSymbol{))}. La aplicación \AgdaSymbol{(}\AgdaField{merge} \AgdaBound{a b}\AgdaSymbol{)} se corresponde con $m_{X,Y}$ e $id_{\mathit{F}Z}$ se refleja simplemente en la variable \AgdaBound{c} ya que aplicar la función identidad sobre ella da el mismo resultado. No es necesario generar la función producto de estas dos puesto que \AgdaField{merge} toma sus argumentos por separado. Finalmente, la segunda aplicación de \AgdaField{merge} se corresponde con $m_{X \times Y, Z}$.

En el otro lado de la ecuación, de manera análoga, $m_{X, Y \times Z} \circ (id_{\mathit{F}X} \times m_{Y,Z})$ se corresponde con las siguientes aplicaciones: \AgdaSymbol{(}\AgdaField{merge} \AgdaBound{a} \AgdaSymbol{(}\AgdaField{merge} \AgdaBound{b c}\AgdaSymbol{))}. Quedaría por agregar la aplicación de $\alpha$ al principio, pero esta no es necesaria en este lado de la ecuación puesto que \AgdaField{merge} toma sus argumentos por separado, por lo que no hay ningún producto cartesiano que haya que dar vuelta.

Uniendo todas las partes traducidas y tomando la composición de funciones simplemente como la aplicación de una función al resultado de otra, se obtiene la ecuación presente en \AgdaField{assoc}:
\begin{equation*}
\AgdaSymbol{(}\AgdaField{fmap} \ \AgdaSymbol{($\lambda \ \{$((}\AgdaBound{a} \ \AgdaInductiveConstructor{,} \ \AgdaBound{b}\AgdaSymbol{)} \ \AgdaInductiveConstructor{,} \ \AgdaBound{c}\AgdaSymbol{) \ $\rightarrow$ \ (}\AgdaBound{a} \ \AgdaInductiveConstructor{,} \ \AgdaSymbol{(}\AgdaBound{b} \ \AgdaInductiveConstructor{,} \ \AgdaBound{c}\AgdaSymbol{))\}))} \ \AgdaSymbol{(}\AgdaField{merge} \ \AgdaSymbol{(}\AgdaField{merge} \ \AgdaBound{a b}\AgdaSymbol{)} \  \AgdaBound{c}\AgdaSymbol{))} \ \AgdaField{$\cong_m$} \ \AgdaSymbol{(}\AgdaField{merge} \ \AgdaBound{a} \ \AgdaSymbol{(}\AgdaField{merge} \ \AgdaBound{b c}\AgdaSymbol{))}.
\end{equation*}

En la definición formal hay una condición extra para los funtores monoidales que dice que si la estructura monoidal es además compatible con $\gamma$, la cual intercambia los elementos del producto cartesiano, entonces el funtor monoidal es simétrico. Si se piensa al funtor monoidal como un mecanismo para encapsular efectos de computaciones, entonces que el funtor sea simétrico significaría que el orden de los efectos no importa, es decir que los efectos conmutan. Esta condición extra se refleja en el campo final que se encuentra comentado, \AgdaField{comm}, el cual postula la conmutatividad del operador \AgdaField{merge}. Esta proposición indica que para cualesquiera computaciones \AgdaBound{a} y \AgdaBound{b} de tipo \AgdaBound{M A} y \AgdaBound{M B} respectivamente, la aplicación \AgdaField{merge} \AgdaBound{a b} da el mismo resultado que la aplicación \AgdaField{merge} \AgdaBound{b a} seguida de un \AgdaFunction{swap} que representa a la función $\gamma$. Agregando este último campo se obtiene entonces la formalización de los funtores monoidales simétricos.

\section{Formalización de Monoides Concurrentes}\label{form:monoidconc}

Como paso previo a la formalización de las mónadas concurrentes, se presenta en esta sección la formalización de los monoides concurrentes. Estos son una mezcla entre los monoides y los funtores monoidales e introducen un ingrediente nuevo que luego estará presente también en la formalización de las mónadas concurrentes: la ley de intercambio. Esta formalización está dada también por un tipo \AgdaKeyword{record} parametrizado, donde el parámetro es, al igual que en el caso de los monoides, un conjunto. 

\ExecuteMetaData[latex/Structures/ConcurrentMonoid.tex]{monoidconc}

En la definición \ref{def:bimonord} se presenta a un bimonoide ordenado como un conjunto parcialmente ordenado $(A,\sqsubseteq)$ junto con dos estructuras monoidales $(A,;,\mathtt{skip})$ y $(A,*,\mathtt{nothing})$ tales que $;$ y $*$ son compatibles con $\sqsubseteq$ y $*$ es conmutativa. Luego, en la definición \ref{def:monoidconc} se define a un monoide concurrente como un bimonoide ordenado tal que los neutros coinciden y se cumple la ley de intercambio.

Al igual que en las demás estructuras, los primeros dos campos de \AgdaRecord{Concurrent Monoid} representan la noción de igualdad junto con la prueba de que esta es una relación de equivalencia. De manera similar, el tercer y cuarto campo introducen una relación de orden junto con una prueba de que esta es un orden parcial, es decir que es reflexiva, antisimétrica y transitiva. Esta relación se corresponde con el orden opuesto al orden $\sqsubseteq$ del conjunto que se pide en la definición formal, es decir que \AgdaBound{x} \AgdaField{$\lesssim_m$} \AgdaBound{y} $\Leftrightarrow$ $y \sqsubseteq x$. La decisión de tomar el orden opuesto se debe a los modelos con los que se trabajó en esta tesina, en el siguiente capítulo se comprenderá mejor esta decisión al dar instancias de esta estructura. La relación de orden es necesaria, sobre todo, debido a la presencia de la ley de intercambio, la cual está dada, a diferencia de las demás propiedades, como una desigualdad. Se requiere entonces que exista un orden sobre el conjunto \AgdaBound{M} y este debe ser un orden parcial respecto de la noción de igualdad previamente introducida. Esto significa que las propiedades de reflexividad, antisimetría y transitividad están demostradas respecto de \AgdaField{$\_\cong_m\_$}. La prueba \AgdaField{porder$_m$} de que la relación \AgdaField{$\_\lesssim_m\_$} es un orden parcial está dada por un habitante de \AgdaRecord{IsPartialOrder}, el cual es un tipo \AgdaKeyword{record} definido en el módulo \href{https://agda.github.io/agda-stdlib/Relation.Binary.Structures.html}{\AgdaModule{Relation.Binary.Structures}}.

Los siguientes dos campos, \AgdaField{$\_+_m\_$} y \AgdaField{zero$_m$}, representan la primera estructura monoidal del bimonoide ordenado, es decir, el operador $;$ y su neutro $\mathtt{skip}$. La prueba de que el operador es compatible con la relación de orden se introduce a continuación en el campo \AgdaField{scomp$\lesssim_m$}. Este indica que si se tienen cuatro valores \AgdaBound{x}, \AgdaBound{y}, \AgdaBound{z} y \AgdaBound{w} de tipo \AgdaBound{M}, tales que \AgdaBound{x} \AgdaField{$\lesssim_m$} \AgdaBound{z} e \AgdaBound{y} \AgdaField{$\lesssim_m$} \AgdaBound{w}, entonces la suma de los menores es menor o igual a la suma de los mayores: (\AgdaBound{x} \AgdaField{$+_m$} \AgdaBound{y}) \AgdaField{$\lesssim_m$} (\AgdaBound{z} \AgdaField{$+_m$} \AgdaBound{w}). 

Seguidamente, se presentan las leyes o propiedades de la primera estructura monoidal: \AgdaField{sidl} y \AgdaField{sidr} son las pruebas de que \AgdaField{zero$_m$} es neutro de la operación \AgdaField{$\_+_m\_$}, a izquierda y derecha respectivamente, y \AgdaField{sassoc} es la prueba de que dicha operación es asociativa. Estos tres campos son iguales a los que aparecen en la formalización de monoide, la única diferencia es que se antepone la letra \AgdaField{s} para indicar que estas propiedades pertenecen a la suma. 

A continuación se introduce otra operación binaria sobre el conjunto \AgdaBound{M}: \AgdaField{max$_m$}. Esta operación junto con \AgdaField{zero$_m$} constituyen la segunda estructura monoidal del conjunto. El neutro es el mismo en ambas estructuras debido a que es un monoide concurrente. Se puede pensar a \AgdaField{max$_m$} como una versión simplificada de la operación \AgdaField{merge} de los funtores monoidales. Al igual que para la suma, se da la prueba de que este segundo operador es también compatible con la relación de orden. Esta prueba está representada por el campo \AgdaField{mcomp$\lesssim_m$}, cuyo tipo es muy similar a \AgdaField{scomp$\lesssim_m$}, donde la operación pasa a ser \AgdaField{max$_m$} en lugar de la suma. Los campos que siguen son pruebas de que la estructura (\AgdaField{max$_m$}, \AgdaField{zero$_m$}) es monoidal: \AgdaField{midl} y \AgdaField{midr} representan pruebas de que \AgdaField{zero$_m$} es neutro respecto de \AgdaField{max$_m$}, a izquierda y derecha respectivamente, y \AgdaField{massoc} representa la prueba de que dicha operación es asociativa. Se antepone la \AgdaField{m} delante para indicar que estas propiedades pertenecen a \AgdaField{max$_m$}. Se agrega para esta operación una propiedad extra: la conmutatividad. Esta es requerida para que el monoide sea concurrente y está representada por el campo \AgdaField{mcomm} que indica que, dados dos valores \AgdaBound{x} e \AgdaBound{y} de tipo \AgdaBound{M}, siempre se cumple que (\AgdaField{max$_m$} \AgdaBound{x y}) \AgdaField{$\cong_m$} (\AgdaField{max$_m$} \AgdaBound{y x}).

El último campo de esta estructura representa la ley de intercambio. El tipo del campo \AgdaField{ichange} se obtiene de forma casi directa de la ecuación de la ley de intercambio introducida en la definición \ref{def:monoidconc}: $(x * z) ; (y * w) \sqsubseteq (x ; y) * (z ; w)$. Si se reemplazan los operadores $*$ y $;$ por \AgdaField{max$_m$} y \AgdaField{$+_m$}, respectivamente, y se invierte el orden de la desigualdad como se explicó previamente, se llega a la siguiente ecuación: (\AgdaField{max$_m$} (\AgdaBound{x} \AgdaField{$+_m$} \AgdaBound{y}) (\AgdaBound{z} \AgdaField{$+_m$} \AgdaBound{w})) \AgdaField{$\lesssim_m$} ((\AgdaField{max$_m$} \AgdaBound{x z}) \AgdaField{$+_m$} (\AgdaField{max$_m$} \AgdaBound{y w})).

\section{Formalización de Mónadas Concurrentes}\label{form:monconc}

Se introduce a continuación la formalización de las mónadas concurrentes. Esta estará dada, como en las estructuras algebraicas anteriores, por un tipo \AgdaKeyword{record} parametrizado. Como en el caso de la formalización de mónadas, el parámetro del \AgdaKeyword{record} \AgdaRecord{ConcurrentMonad} será una asignación \hbox{\AgdaBound{M} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaSymbol{$\rightarrow$} \AgdaPrimitiveType{Set}}, la cual representa la asignación de objetos a objetos de un funtor $\mathit{M} : \text{\bf Set} \rightarrow \text{\bf Set}$.

\ExecuteMetaData[latex/Structures/ConcurrentMonad.tex]{monconc}

Siguiendo el ejemplo de las mónadas, el primer campo de esta estructura es una noción de igualdad sobre el conjunto \AgdaBound{M A}, para un \AgdaBound{A} arbitrario. De igual manera, el segundo campo es la prueba de que la relación anterior es de equivalencia, y también debe darse para un \AgdaBound{A} arbitrario. Como se explicó anteriormente, es necesario que el conjunto \AgdaBound{A} pueda tomar diferentes valores ya que el funtor \AgdaBound{M} se aplicará a distintos conjuntos a lo largo de la estructura. Es por esta misma razón que los dos campos que siguen también deben definirse para cualquier conjunto \AgdaBound{A}. 

En la definición \ref{def:monconc} se expone que para que una mónada sea concurrente debe ser primero una mónada monoidal ordenada. La definición \ref{def:monmonord}, por su lado, indica que para que una mónada sea una mónada monoidal ordenada debe contar con una estructura de funtor monoidal simétrico $(m,e)$ y una relación de orden compatible con la misma. Es así como, de manera similar a la formalización de monoides, el tercer campo introduce una relación de orden entre elementos de \AgdaBound{M A}, para algún \AgdaBound{A} dado. A continuación, en el cuarto campo, se da la prueba de que dicha relación es un orden parcial, es decir que es reflexiva, antisimétrica y transitiva. Estas pruebas se dan en torno a la noción de igualdad definida previamente. Al igual que en los monoides concurrentes, el orden considerado es el opuesto al utilizado en la teoría, de manera que \AgdaBound{x} \AgdaField{$\lesssim_m$} \AgdaBound{y} $\Leftrightarrow$ $y \sqsubseteq x$. 

Los campos siguientes introducen la estructura monádica. Estos están dados, al igual que en la formalización de mónada, siguiendo la definición de mónadas como sistemas de extensión (definición \ref{def:sistext}). La función \AgdaField{return} toma un elemento de un conjunto \AgdaBound{A} arbitrario y lo encapsula en la mónada, devolviendo un habitante del tipo \AgdaBound{M A}, mientras que el operador \AgdaField{$\gg=$} sirve para secuenciar dos computaciones. 

Antes de pasar a las leyes de las mónadas, se introduce la compatibilidad del operador \AgdaField{$\gg=$} con la relación de orden. Esta propiedad está dada por el campo \AgdaField{bcomp$\lesssim_m$}. En la definición \ref{def:ordmon}, se define una mónada ordenada como una mónada que tiene un orden $\sqsubseteq_I$ sobre $\mathit{T} I$ para cada conjunto $I$, donde este orden enriquece a los morfismos $A \rightarrow \mathit{T} B$ con un orden $\sqsubseteq_{A,B}$ tal que $f \sqsubseteq_{A,B} g$ si y sólo si $\forall a: \mathbf{1} \rightarrow A, f \circ a \sqsubseteq_B g \circ a$. En Agda, como ya se mencionó anteriormente, no tiene sentido considerar una función que toma elementos del conjunto $\mathbf{1}$ (\AgdaDatatype{$\top$} en Agda) puesto que este tiene un único elemento. Luego, en lugar de tomar morfismos $a : \mathbf{1} \rightarrow A$, se toman directamente valores \AgdaBound{a} $:$ \AgdaBound{A}. Se considera entonces que una función \AgdaBound{f$_1$} $:$ \AgdaBound{A} $\rightarrow$ \AgdaBound{M B} es menor o igual a una función \AgdaBound{f$_2$} $:$ \AgdaBound{A} $\rightarrow$ \AgdaBound{M B} si y sólo si para todo \AgdaBound{a} $:$ \AgdaBound{A} se cumple que (\AgdaBound{f$_1$ a}) \AgdaField{$\lesssim_m$} (\AgdaBound{f$_2$ a}). La compatibilidad del operador \AgdaField{$\gg=$} con el orden \AgdaField{$\lesssim_m$} se define entonces de la siguiente manera: dados dos valores \AgdaBound{a$_1$} y \AgdaBound{a$_2$} de tipo \hbox{\AgdaBound{M A}} y dos funciones \AgdaBound{f$_1$} y \AgdaBound{f$_2$} de tipo \AgdaBound{A} $\rightarrow$ \AgdaBound{M B}, si se tiene que \hbox{\AgdaBound{a$_1$} \AgdaField{$\lesssim_m$} \AgdaBound{a$_2$}} y \AgdaSymbol{$\forall$} (\AgdaBound{a} $:$ \AgdaBound{A}) $\rightarrow$ (\AgdaBound{f$_1$ a}) \AgdaField{$\lesssim_m$} (\AgdaBound{f$_2$ a}), entonces (\AgdaBound{a$_1$} \AgdaField{$\gg=$} \AgdaBound{f$_1$}) \AgdaField{$\lesssim_m$} (\AgdaBound{a$_2$} \AgdaField{$\gg=$} \AgdaBound{f$_2$}).

Los campos \AgdaField{monad$_1$}, \AgdaField{monad$_2$} y \AgdaField{monad$_3$} representan las tres leyes de mónadas y son iguales a los campos \AgdaField{law$_1$}, \AgdaField{law$_2$} y \AgdaField{law$_3$} de \AgdaRecord{Monad}. Los primeros dos indican que \AgdaField{return} es neutro a derecha e izquierda de \AgdaField{$\gg=$} y el último indica la asociatividad de dicho operador.

Una vez establecida la estructura monádica, se pasa a introducir la estructura monoidal que se requiere en la definición \ref{def:monmonord} para que la mónada sea una mónada monoidal ordenada. El elemento neutro es un morfismo $e : \mathbf{1} \rightarrow \mathit{M} \mathbf{1}$. Como se mencionó anteriormente, el objeto terminal $\mathbf{1} = \{\star\} \in \text{\bf ob Set}$ se representa en Agda como el tipo \AgdaDatatype{$\top$}, cuyo único habitante es \AgdaInductiveConstructor{tt}. Al ser un conjunto de un único elemento, al igual que en el caso de la formalización de funtor monoidal, $e$ se define como un campo \AgdaField{unit} de tipo \AgdaBound{M} \AgdaDatatype{$\top$} en lugar de como una función de tipo \AgdaDatatype{$\top$} \AgdaSymbol{$\rightarrow$} \AgdaBound{M} \AgdaDatatype{$\top$} ya que hay un único argumento posible para la función. Según la definición \ref{def:monconc}, para que la mónada sea una mónada concurrente, el morfismo $e$ debe ser igual a $\eta_{\mathbf{1}} : \mathbf{1} \rightarrow \mathit{M} \mathbf{1}$. Considerando $\mathbf{1} =$ \AgdaDatatype{$\top$}, luego $e$ debería ser igual a \AgdaField{return} \AgdaSymbol{\{}\AgdaDatatype{$\top$}\AgdaSymbol{\} :} \AgdaDatatype{$\top$} \AgdaSymbol{$\rightarrow$} \AgdaBound{M} \AgdaDatatype{$\top$}. Como \AgdaDatatype{$\top$} tiene un único habitante, se obtiene que \AgdaField{unit} debe ser igual a \AgdaField{return} \AgdaInductiveConstructor{tt} \AgdaSymbol{:} \AgdaBound{M} \AgdaDatatype{$\top$}. {\color{red} Cómo defino unit = return tt? dentro de la estructura?}

Continuando con la estructura monoidal, el siguiente campo es la función \AgdaField{merge}, la cual representa la transformación natural $m$. Este campo está definido de igual manera que el \AgdaField{merge} de \AgdaRecord{MonoidalFunctor}. En dicha estructura, a continuación del \AgdaField{merge} se introduce el campo \AgdaField{fmap}, el cual representa la asignación de morfismos a morfismos del funtor $\mathit{M}$. En el caso de las mónadas concurrentes este campo no es necesario puesto que puede construirse tal asignación a partir del operador \AgdaField{$\gg=$}. Sea \AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{$\rightarrow$}  \AgdaBound{B} una función, luego (\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} $f$ \AgdaBound{a})) es una función de tipo \AgdaBound{M A} \AgdaSymbol{$\rightarrow$} \AgdaBound{M B}. De esta manera la asignación de morfismos a morfismos del funtor queda definida. {\color{red} Comentario: demostrar equivalencia? Se demostraría para un caso particular igual, no? Porque no tengo una definición de fmap concreta acá} 

El campo que sigue, \AgdaField{mcomp$\lesssim_m$}, representa la compatibilidad del operador \AgdaField{merge} con la relación de orden \AgdaField{$\lesssim_m$}. Dados \AgdaBound{a$_1$} y \AgdaBound{a$_2$} de tipo \AgdaBound{M A} y \AgdaBound{b$_1$} y \AgdaBound{b$_2$} de tipo \AgdaBound{M B}, si se tiene que \hbox{\AgdaBound{a$_1$} \AgdaField{$\lesssim_m$} \AgdaBound{a$_2$}} y \AgdaBound{b$_1$} \AgdaField{$\lesssim_m$} \AgdaBound{b$_2$}, luego se debe cumplir que (\AgdaField{merge} \AgdaBound{a$_1$ b$_1$}) \AgdaField{$\lesssim_m$} (\AgdaField{merge} \AgdaBound{a$_2$ b$_2$}). 

Es el turno ahora de las propiedades que deben cumplirse para que \AgdaField{merge} y \AgdaField{unit} formen una estructura monoidal. Estas propiedades son tres y están definidas de manera similar a las de la formalización de funtor monoidal, salvo por el uso del campo \AgdaField{fmap}. \AgdaField{idr} representa la proposición que indica que \AgdaField{unit} es un neutro a derecha del operador \AgdaField{merge}. En el \AgdaKeyword{record} \AgdaRecord{MonoidalFunctor} esta propiedad tiene tipo \hbox{\AgdaSymbol{$\forall$} \{\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) \AgdaSymbol{$\rightarrow$} (\AgdaField{merge unit} \AgdaBound{a}) \AgdaField{$\cong_m$} (\AgdaField{fmap} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) \AgdaBound{a})}. Reemplazando \AgdaField{fmap} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) por la función propuesta anteriormente, donde se sustituye $f$ por (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})), quedaría el siguiente tipo: 
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) \AgdaSymbol{$\rightarrow$} (\AgdaField{merge unit} \AgdaBound{a}) \AgdaField{$\cong_m$}  \\ ((\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) \AgdaBound{a})) \AgdaBound{a})
\end{center}

Si se reduce la aplicación (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) \AgdaBound{a}, se obtiene un tipo un poco más reducido:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) \AgdaSymbol{$\rightarrow$} (\AgdaField{merge unit} \AgdaBound{a}) \AgdaField{$\cong_m$} ((\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaBound{a} \AgdaInductiveConstructor{, tt}))) \AgdaBound{a})
\end{center}

Si se reduce finalmente la aplicación (\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaBound{a} \AgdaInductiveConstructor{, tt}))) \AgdaBound{a}, se obtiene el tipo del campo \AgdaField{idr} en la estructura:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) \AgdaSymbol{$\rightarrow$} (\AgdaField{merge unit} \AgdaBound{a}) \AgdaField{$\cong_m$} (\AgdaBound{a} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaBound{a} \AgdaInductiveConstructor{, tt})))
\end{center}

De manera análoga, si se reemplaza \AgdaField{fmap} por su versión construida con \textit{bind} en el tipo del campo \AgdaField{idl} de \AgdaRecord{MonoidalFunctor} y luego se reducen las aplicaciones, se obtiene el tipo del campo \AgdaField{idl} de \AgdaRecord{ConcurrentMonad}. Este representa la propiedad que postula que \AgdaField{unit} es neutro a izquierda del operador \AgdaField{merge}. 

La última de estas tres propiedades, \AgdaField{assoc}, representa la asociatividad del operador \AgdaField{merge}. En la estructura de funtor monoidal esta ley estaba definida con el siguiente tipo:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A B C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) (\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{M B}) (\AgdaBound{c} \AgdaSymbol{:} \AgdaBound{M C}) \AgdaSymbol{$\rightarrow$} \\ (\AgdaField{fmap} (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) (\AgdaField{merge} (\AgdaField{merge} \AgdaBound{a b}) \AgdaBound{c})) \AgdaField{$\cong_m$} (\AgdaField{merge} \AgdaBound{a} (\AgdaField{merge} \AgdaBound{b c}))
\end{center}

Reemplazando \AgdaField{fmap} (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) por la función equivalente a \AgdaField{fmap}, donde la $f$ sería sustituída por la función (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}), el tipo queda como sigue:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A B C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) (\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{M B}) (\AgdaBound{c} \AgdaSymbol{:} \AgdaBound{M C}) \AgdaSymbol{$\rightarrow$} \\ ((\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \AgdaBound{a} \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) \AgdaBound{a})) (\AgdaField{merge} (\AgdaField{merge} \AgdaBound{a b}) \AgdaBound{c})) \AgdaField{$\cong_m$} (\AgdaField{merge} \AgdaBound{a} (\AgdaField{merge} \AgdaBound{b c}))
\end{center}

La aplicación (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) \AgdaBound{a})) se puede reducir, pero para esto es necesario hacer \textit{pattern matching} en la variable \AgdaBound{a} de manera que se pueda acceder a sus componentes, ya que esta es un elemento de un producto cartesiano. El resultado de abrir la variable \AgdaBound{a} y luego reducir la aplicación es el tipo:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A B C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) (\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{M B}) (\AgdaBound{c} \AgdaSymbol{:} \AgdaBound{M C}) \AgdaSymbol{$\rightarrow$} \\ ((\AgdaSymbol{$\lambda$} \AgdaBound{ma} \AgdaSymbol{$\rightarrow$} \AgdaBound{ma} \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\})) (\AgdaField{merge} (\AgdaField{merge} \AgdaBound{a b}) \AgdaBound{c})) \\ \AgdaField{$\cong_m$} (\AgdaField{merge} \AgdaBound{a} (\AgdaField{merge} \AgdaBound{b c}))
\end{center}

Se puede reducir ahora el lado izquierdo de la ecuación, reemplazando la variable \AgdaBound{ma} por (\AgdaField{merge} (\AgdaField{merge} \AgdaBound{a b}) \AgdaBound{c}). El resultado de hacer este reemplazo es el siguiente tipo, el cual es el tipo del campo \AgdaField{assoc} de \AgdaRecord{ConcurrentMonad}:
\begin{center}
\AgdaSymbol{$\forall$} \{\AgdaBound{A B C} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\} \AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaSymbol{:} \AgdaBound{M A}) (\AgdaBound{b} \AgdaSymbol{:} \AgdaBound{M B}) (\AgdaBound{c} \AgdaSymbol{:} \AgdaBound{M C}) \AgdaSymbol{$\rightarrow$} \\ ((\AgdaField{merge} (\AgdaField{merge} \AgdaBound{a b}) \AgdaBound{c}) \AgdaField{$\gg=$} (\AgdaSymbol{$\lambda$} \{((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c}) \AgdaSymbol{$\rightarrow$} \AgdaField{return} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\})) \AgdaField{$\cong_m$} (\AgdaField{merge} \AgdaBound{a} (\AgdaField{merge} \AgdaBound{b c}))
\end{center}

Como se mencionó anteriormente, para que la mónada sea una mónada monoidal ordenada, esta debe contar con una estructura de funtor monoidal simétrico. Para que sea simétrico, además de las leyes que se probaron sobre la estructura monoidal, debe haber una propiedad extra: la conmutatividad del operador \AgdaField{merge}. Esta propiedad se representa con el campo \AgdaField{comm}. El tipo de este campo se construye de manera similar al anterior, donde de un lado se tiene simplemente (\AgdaField{merge} \AgdaBound{a b}), y del otro se aplica (\AgdaField{merge} \AgdaBound{b a}) seguido de una aplicación de \AgdaField{$\gg=$} con una función que da vuelta el orden del producto cartesiano. 

Queda por analizar el último campo de la estructura, el cual postula la relación que deben tener los operadores \AgdaField{$\gg=$} y \AgdaField{merge} para que la mónada sea concurrente. Este se denomina \AgdaField{ichange} y representa la ley de intercambio. Sean \AgdaBound{a$'$} $:$ $\mathbf{1} \rightarrow \mathit{M} A$, \AgdaBound{b$'$} $:$ $\mathbf{1} \rightarrow \mathit{M} B$, \AgdaBound{f} $:$ $A \rightarrow \mathit{M} C$ y \AgdaBound{g} $:$ $B \rightarrow \mathit{M} D$. {\color{red} Comentario: puse que a' y b' sean $1 \rightarrow M X$ porque en la formalización en realidad son directamente $M X$, pero en la teoría la ley se da con todas funciones. Cierra todo pero queda medio sin justificar por qué inicialmente los tomo así y no como funciones cualesquiera, como podría mejorar esto?} En la definición \ref{def:monconc}, se presenta la ley de intercambio de la siguiente manera: $(f \star g) \bullet (a' \star b') \sqsubseteq (f \bullet a') \star (g \bullet b')$, donde $f \star g = m \circ (f \times g)$ y $f \bullet g = f^* \circ g$. Esta ley se puede reescribir entonces como:
\begin{equation*}
(m \circ (f \times g))^* \circ (m \circ (a' \times b')) \sqsubseteq (m \circ ((f^* \circ a') \times (g^* \circ b')))
\end{equation*}

Como ya sucedió varias veces a lo largo del proceso de formalización, se tienen en este caso dos funciones que tienen como dominio el conjunto terminal $\mathbf{1}$. De igual manera que en las demás ocasiones, estas serán representadas en la formalización de manera simplificada, en el caso de \AgdaBound{a$'$} se tomará un \AgdaBound{a} $:$ \AgdaBound{M A}, y en el caso de \AgdaBound{b$'$} se tomará un \AgdaBound{b} $:$ \AgdaBound{M B}. Haciendo estos cambios, la fórmula se reescribe como se muestra a continuación:
\begin{equation*}
(m \circ (f \times g))^* \ (m\ (a\  \AgdaInductiveConstructor{,}\ b)) \sqsubseteq (m \circ ((f^*\ a) \times (g^*\ b)))
\end{equation*}

La transformación natural $m$ se reemplaza en la formalización dada con el operador \AgdaField{merge}, el cual no toma un par ordenado sino dos elementos por separado. Haciendo este reemplazo se obtiene la siguiente fórmula:
\begin{equation*}
(\AgdaField{merge} \circ (f \times g))^* \ (\AgdaField{merge}\ a\ b) \sqsubseteq (\AgdaField{merge}\ (f^*\ a)\ (g^*\ b))
\end{equation*}

El operador $\_^*$, por su parte, está representado por la función \AgdaField{$\gg=$}, donde la expresión $h^* x$ es equivalente a escribir \AgdaBound{x} \AgdaField{$\gg=$} \AgdaBound{h}. Luego de hacer esta sustitución la fórmula queda como sigue:
\begin{equation*}
(\AgdaField{merge}\ a\ b) \ \AgdaField{$\gg=$} \ (\AgdaField{merge} \circ (f \times g)) \sqsubseteq (\AgdaField{merge} \ (a\ \AgdaField{$\gg=$}\ f) \ (b\ \AgdaField{$\gg=$}\ g))
\end{equation*}

La aplicación (\AgdaField{merge} $\circ \ (f \times g)$) se reescribe en Agda como una función que toma un par \hbox{(\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b})}, aplica la función $f$ a \AgdaBound{a} y la función $g$ a \AgdaBound{b}, y luego el operador \AgdaField{merge} a los dos resultados obtenidos. Es decir, se expresa de la siguiente manera: ($\lambda$ \{ (\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) $\rightarrow$ (\AgdaField{merge} (\AgdaBound{f a}) (\AgdaBound{g b})) \} ). Haciendo esta sustitución y cambiando el orden $\sqsubseteq$ por el campo \AgdaField{$\lesssim_m$} (invirtiendo el orden de la desigualdad puesto que se toma el orden opuesto), se obtiene finalmente el tipo del campo \AgdaField{ichange}:
\begin{equation*}
(\AgdaField{merge} \ (a\ \AgdaField{$\gg=$}\ f) \ (b\ \AgdaField{$\gg=$}\ g)) \ \AgdaField{$\lesssim_m$} \ (\AgdaField{merge}\ a\ b) \ \AgdaField{$\gg=$} \ (\lambda\  \{\ (\AgdaBound{a} \ \AgdaInductiveConstructor{,} \ \AgdaBound{b}) \ \rightarrow \ (\AgdaField{merge} \ (\AgdaBound{f a}) \ (\AgdaBound{g b})) \ \}\ ) 
\end{equation*}
