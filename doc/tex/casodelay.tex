\chapter{El caso de la Mónada Delay}\label{chapter:casodelay}

Como se mencionó en el capítulo \ref{chapter:delay}, el tipo \textit{delay} fue introducido por Capretta \cite{capretta:2005} para representar la posible no terminación de programas en la teoría de tipos de Martin-Löf. Sus habitantes son valores ``demorados'', los cuales pueden no terminar nunca. El objetivo de este capítulo es hacer un análisis de este tipo respecto de las estructuras algebraicas previamente definidas. 

Inicialmente se dará la definición de este tipo en Agda, utilizando para ello la notación musical para tipos coinductivos que fue descripta en la sección \ref{coind:agda:musical}. Junto con el tipo se definirán diversas relaciones sobre él, entre las que se encuentran las bisemejanzas débil y fuerte y una relación de orden. La implementación del tipo \textit{delay} utilizada fue extraída de la librería \href{https://agda.github.io/agda-stdlib/Effect.Monad.Partiality.html}{\AgdaModule{Effect.Monad.Partiality}}.

Una vez introducido el tipo, se demostrará que este tiene estructura de mónada y de funtor monoidal. Para esto se crearán instancias de las estructuras correspondientes para el tipo \textit{delay}. El objetivo final de este capítulo es probar o refutar que el tipo definido tiene estructura de mónada concurrente. La principal dificultad para esto subyace en la prueba de la ley de intercambio, ya que los demás ingredientes están presentes en las pruebas de mónada y funtor monoidal. 

\section{Definición del tipo \textit{delay} con notación musical}\label{casodelay:defmus}

El tipo \textit{delay} se define con notación musical mediante una estructura \AgdaKeyword{data} parametrizada. El parámetro será un conjunto \AgdaBound{A} de tipo \AgdaPrimitiveType{Set}, el cual representa el tipo de los valores de retorno (en caso de que el programa termine). Dado entonces un \AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}, el tipo \AgdaBound{A} \AgdaDatatype{$\bot$} representa el tipo $\mathbf{D}$\AgdaBound{A} definido en la sección \ref{delay:delay}. 

\ExecuteMetaData[latex/Delay.tex]{bottom}

El constructor \AgdaInductiveConstructor{now} toma un valor \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} y genera un valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}. La expresión \AgdaInductiveConstructor{now} \AgdaBound{x} representa un programa que simplemente retorna el valor \AgdaBound{x} sin demoras. 
El constructor \AgdaInductiveConstructor{later} toma un \AgdaBound{x} de tipo \AgdaFunction{$\infty$} (\AgdaBound{A} \AgdaDatatype{$\bot$}), es decir un valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} suspendido o demorado. Que el valor este suspendido o demorado implica que puede ser potencialmente infinito. El constructor \AgdaInductiveConstructor{later} retorna otro valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}. Intuitivamente, lo que hace este constructor es ``agregar una demora'' al valor recibido. 

Un habitante del tipo \AgdaBound{A} \AgdaDatatype{$\bot$} puede ser una secuencia finita de constructores \AgdaInductiveConstructor{later} que finalmente retorna un valor \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}, es decir algo del estilo \AgdaInductiveConstructor{later} (\AgdaFunction{$\sharp$} (\AgdaInductiveConstructor{later} (\AgdaFunction{$\sharp$} ... (\AgdaInductiveConstructor{now} \AgdaBound{x}) ...))); o puede ser una secuencia infinita de constructores \AgdaInductiveConstructor{later} que nunca retorna. Este último es el caso del valor \AgdaFunction{never} que se define a continuación. 

\ExecuteMetaData[latex/Delay.tex]{never}

El tipo \AgdaDatatype{\_$\bot$} viene con dos formas de igualdad (bisemejanza débil y fuerte) y una relación de orden. La bisemejanza fuerte es más fuerte que el orden y, a su vez, este último es más fuerte que la bisemejanza débil. Las tres relaciones se definen utilizando un único tipo \AgdaKeyword{data}, el cual estará indexado por un valor de tipo \AgdaDatatype{Kind} que indica qué tipo de relación es. Este último se define de la siguiente manera:

\ExecuteMetaData[latex/Delay.tex]{kind}

El constructor \AgdaInductiveConstructor{strong} representa la bisemejanza fuerte, mientras que \AgdaInductiveConstructor{other} \AgdaBound{k} representa la relación de orden si \AgdaBound{k} = \AgdaInductiveConstructor{geq}, o la bisemejanza débil si \AgdaBound{k} = \AgdaInductiveConstructor{weak}. La igualdad entre tipos de igualdad, es decir entre valores del tipo \AgdaDatatype{Kind}, es decidible. El operador \AgdaFunction{$\stackrel{?}{=}$-Kind} toma dos tipos de igualdad y decide si son iguales o no, dando a su vez una prueba de ello. 

\ExecuteMetaData[latex/Delay.tex]{deckind} 

Como se puede ver, la definición de esta función es muy sencilla. Para los casos en que ambos tipos son el mismo la prueba es simplemente \AgdaFunction{refl}, y en los casos en que no lo son, la prueba es el patrón absurdo, puesto que no hay manera de dar una prueba de igualdad entre ellos. Esta función sirve para definir un predicado que indica si la relación es de igualdad o no. Este predicado será verdadero para \AgdaInductiveConstructor{strong} y \AgdaInductiveConstructor{other weak}, pero no para \AgdaInductiveConstructor{other geq}. Será de utilidad tener este predicado a la hora de probar que las igualdades son relaciones de equivalencia.

\ExecuteMetaData[latex/Delay.tex]{equality}

Una vez introducido el tipo \AgdaDatatype{Kind}, se definen las relaciones propiamente dichas. Esto se realiza mediante la creación de un módulo llamado \AgdaModule{Equality}, el cual toma como parámetros un conjunto \AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}, que será el tipo de retorno, y una relación \AgdaBound{$\_\sim\_$} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{$\rightarrow$} \AgdaBound{A} \AgdaSymbol{$\rightarrow$} \AgdaPrimitiveType{Set} que establece una noción de igualdad entre valores de tipo \AgdaBound{A}. 

\ExecuteMetaData[latex/Delay.tex]{rel}

Las relaciones se definen a través del tipo \AgdaDatatype{Rel}, el cual toma como parámetro un \AgdaDatatype{Kind} que indica qué tipo de relación es y dos valores de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}, los cuales va a comparar mediante la relación correspondiente. El tipo \AgdaDatatype{Rel} tiene cuatro constructores:
\begin{itemize}[noitemsep]
\item El constructor \AgdaInductiveConstructor{now} indica que, si se tiene una prueba de que dos valores \AgdaBound{x} e \AgdaBound{y} de tipo \AgdaBound{A} están relacionados por la relación \AgdaBound{$\sim$}, es decir que son iguales en \AgdaBound{A}, entonces los términos (\AgdaInductiveConstructor{now} \AgdaBound{x}) y (\AgdaInductiveConstructor{now} \AgdaBound{y}) están relacionados en \AgdaBound{A} \AgdaDatatype{$\bot$} para los tres tipos de relación posibles. Esto está dado por la utilización de la variable \AgdaBound{k} que puede tomar cualquier valor de tipo \AgdaDatatype{Kind} y quiere decir que (\AgdaInductiveConstructor{now} \AgdaBound{x}) y (\AgdaInductiveConstructor{now} \AgdaBound{y}) son bisemejantes tanto débil como fuertemente, y que además (\AgdaInductiveConstructor{now} \AgdaBound{x}) es mayor o igual a (\AgdaInductiveConstructor{now} \AgdaBound{y}).

\item El constructor \AgdaInductiveConstructor{later} también sirve para las tres relaciones. En este caso, los \AgdaBound{x} e \AgdaBound{y} que recibe como parámetros implícitos son de tipo \AgdaFunction{$\infty$} \AgdaBound{A} \AgdaDatatype{$\bot$} (valores de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} posiblemente infinitos). Este constructor pide una prueba (posiblemente infinita) de que (\AgdaField{$\flat$} \AgdaBound{x}) y (\AgdaField{$\flat$} \AgdaBound{y}) están relacionados por la relación \AgdaBound{k} y afirma que entonces (\AgdaInductiveConstructor{later} \AgdaBound{x}) y (\AgdaInductiveConstructor{later} \AgdaBound{y}) están relacionados por la misma relación \AgdaBound{k}.

\item El constructor \AgdaInductiveConstructor{later$^r$} se puede utilizar únicamente para bisemejanza débil. Dados \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} e \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{$\infty$} \AgdaBound{A} \AgdaDatatype{$\bot$} que son parámetros implícitos y una prueba de que \AgdaBound{x} y (\AgdaField{$\flat$} \AgdaBound{y}) son débilmente bisemejantes, este constructor afirma que entonces \AgdaBound{x} y (\AgdaInductiveConstructor{later} \AgdaBound{y}) son débilmente bisemejantes también. Intuitivamente, \AgdaInductiveConstructor{later$^r$} permite agregar un constructor \AgdaInductiveConstructor{later} en el lado derecho de una bisemejanza débil.

\item El constructor \AgdaInductiveConstructor{later$^l$} es análogo a \AgdaInductiveConstructor{later$^r$} e, intuitivamente, permite agregar un constructor \AgdaInductiveConstructor{later} en el lado izquierdo de una relación que, en este caso, puede ser bisemejanza débil o desigualdad. Esto se evidencia en el uso de la variable \AgdaBound{k} que tiene tipo \AgdaDatatype{OtherKind} ya que luego en el tipo de relación que se le pasa a \AgdaDatatype{Rel} se utiliza (\AgdaInductiveConstructor{other} \AgdaBound{k}), quedando claro por qué al definir el tipo \AgdaDatatype{Kind} se separa el tipo \AgdaInductiveConstructor{strong} de los otros dos. 
\end{itemize}

En el uso que permite cada constructor se puede ver que la relación de tipo \AgdaInductiveConstructor{strong} es la más restrictiva, permitiendo únicamente agregar constructores \AgdaInductiveConstructor{later} a ambos lados de la igualdad, mientras que la desigualdad (\AgdaInductiveConstructor{other geq}) es un poco más débil ya que permite también agregar sólo a izquierda y la bisemejanza débil es la más débil de todas ya que permite agregar a ambos lados por separado.

Luego del tipo \AgdaDatatype{Rel} se definen los operadores \AgdaFunction{$\cong$}, \AgdaFunction{$\gtrsim$}, \AgdaFunction{$\lesssim$} y \AgdaFunction{$\approx$}, los cuales representan la bisemejanza fuerte, la desigualdad (mayor o igual), la desigualdad invertida (menor o igual) y la bisemejanza débil, respectivamente. 

\ExecuteMetaData[latex/Delay.tex]{op}

A continuación, se definen otros operadores que tienen que ver con la noción de convergencia introducida en la definición \ref{def:convergencia}. 

\ExecuteMetaData[latex/Delay.tex]{convergencia}

\AgdaBound{x} \AgdaFunction{$\Downarrow$[} \AgdaBound{k} \AgdaFunction{]} \AgdaBound{y} indica que \AgdaBound{x} se relaciona mediante la relación \AgdaBound{k} con (\AgdaInductiveConstructor{now} \AgdaBound{y}). En el caso especial de que la relación sea bisemejanza débil, se escribe \AgdaBound{x} \AgdaFunction{$\Downarrow$} \AgdaBound{y} y se dice que \AgdaBound{x} converge al valor \AgdaBound{y} \AgdaSymbol{:} \AgdaBound{A}. Por otro lado, \AgdaBound{x} \AgdaFunction{$\Downarrow$} indica que la computación \AgdaBound{x} termina, es decir que existe algún valor \AgdaBound{v} tal que \AgdaBound{x} \AgdaFunction{$\Downarrow$} \AgdaBound{v}. Por último, \AgdaBound{x} \AgdaFunction{$\Uparrow$[} \AgdaBound{k} \AgdaFunction{]} indica que \AgdaBound{x} se relaciona con el valor especial \AgdaFunction{never} mediante la relación \AgdaBound{k}. En el caso de que esa relación sea (\AgdaInductiveConstructor{other weak}) se escribe \AgdaBound{x} \AgdaFunction{$\Uparrow$} y se dice que la computación \AgdaBound{x} no termina.

Luego de dar todas las definiciones, se prueba que las tres relaciones son reflexivas y transitivas y que las bisemejanzas son simétricas mientras que la desigualdad es antisimétrica. Antes de poder demostrar esto, se prueba un conjunto de lemas que serán de utilidad para tal propósito. Todas estas pruebas se sitúan dentro de un módulo sin nombre parametrizado con el conjunto \AgdaBound{A} de retorno y su relación de igualdad. Esto se hace para fijar tal conjunto y su relación y poder utilizarlos a lo largo de todas las demostraciones.

\ExecuteMetaData[latex/Delay.tex]{lemas}

El lema \AgdaFunction{$\cong\Rightarrow$} demuestra que todas las relaciones incluyen a la bisemejanza fuerte, es decir que si dos términos \AgdaBound{x y} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} son fuertemente bisemejantes, entonces también son débilmente bisemejantes y, además, \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y}. De manera similar, el segundo lema, \AgdaFunction{$\gtrsim\Rightarrow$}, postula que la desigualdad está incluída en la bisemejanza débil. Si \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y}, entonces \AgdaBound{x} e \AgdaBound{y} son débilmente bisemejantes. Por último, el lema \AgdaFunction{$\Rightarrow\approx$} indica que todas las relaciones están incluídas en la bisemejanza débil. Si \AgdaBound{x} e \AgdaBound{y} se relacionan mediante cualquier tipo de relación \AgdaBound{k}, entonces también se relacionan por la bisemejanza débil. 

Las definiciones que siguen representan las operaciones inversas de los constructores \AgdaInductiveConstructor{later$^r$}, \AgdaInductiveConstructor{later$^l$} y \AgdaInductiveConstructor{later}. Así como estos constructores permiten ``agregar demoras'' a uno y otro lado de las ecuaciones, sus operaciones inversas permiten ``quitar demoras'' para ciertos tipos de relaciones. 

\ExecuteMetaData[latex/Delay.tex]{inversas}

La función \AgdaFunction{later$^{r-1}$} permite sacar un constructor \AgdaInductiveConstructor{later} del lado derecho de una ecuación que tenga como operador a la desigualdad o la bisemejanza débil. Si se tiene \hbox{\AgdaDatatype{Rel} (\AgdaInductiveConstructor{other} \AgdaBound{k}) \AgdaBound{x} (\AgdaInductiveConstructor{later} \AgdaBound{y})}, para algún tipo \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{OtherKind} y algún par de términos \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} e \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{$\infty$} (\AgdaBound{A} \AgdaDatatype{$\bot$}), entonces se tiene que \AgdaBound{x} se relaciona por el mismo tipo de relación \AgdaBound{k} con (\AgdaField{$\flat$} \AgdaBound{y}). La función \AgdaFunction{later$^{l-1}$}, de manera análoga, permite quitar un constructor \AgdaInductiveConstructor{later} del lado izquierdo de la ecuación, pero sólo para el caso de la bisemejanza débil. Esto implica que si se tiene \AgdaInductiveConstructor{later} \AgdaBound{x} \AgdaFunction{$\approx$} \AgdaBound{y}, entonces también se cumple que \AgdaField{$\flat$} \AgdaBound{x} \AgdaFunction{$\approx$} \AgdaBound{y}. Por último, la función \AgdaFunction{later$^{-1}$} permite quitar el constructor  \AgdaInductiveConstructor{later} de ambos lados de la ecuación. Esto puede realizarse para cualquier tipo de relación \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{Kind}.

Teniendo en cuenta todos estos lemas se pueden probar finalmente las propiedades que cumplen las relaciones definidas. Para poder realizar estas demostraciones se asumen las propiedades análogas para la relación subyacente \AgdaFunction{$\_\sim\_$} sobre el conjunto de retorno \AgdaBound{A}. Se realizan dichas pruebas dentro de un módulo llamado \AgdaModule{Equivalence} que las encapsula para luego importarlas todas juntas cuando sean necesarias. 

\ExecuteMetaData[latex/Delay.tex]{refl}

La reflexividad se prueba para cualquier tipo de relación \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{Kind}. Se pide como condición una prueba de que la relación subyacente \AgdaFunction{$\_\sim\_$} es también reflexiva. Tanto la prueba argumento como la prueba que se retorna están dadas por un término de tipo \AgdaFunction{Reflexive} definido en el módulo \href{https://agda.github.io/agda-stdlib/Relation.Binary.Definitions.html}{\AgdaModule{Relation.Binary.Definitions}}. Este es una función que toma una relación binaria \AgdaBound{$\_\sim\_$} y devuelve el tipo correspondiente a la prueba de que dicha relación es reflexiva, es decir $\forall$ \{\AgdaBound{x}\} $\rightarrow$ \AgdaBound{x $\sim$ x}. De manera análoga, la prueba de simetría se da mediante un término de tipo \AgdaFunction{Symmetric} que, dada una relación, devuelve el tipo de la prueba que indica que tal relación es simétrica.

\ExecuteMetaData[latex/Delay.tex]{sym}

La prueba de simetría requiere, además de la prueba de que la relación subyacente \AgdaFunction{$\_\sim\_$} es simétrica, una prueba de que el tipo de relación \AgdaBound{k} : \AgdaDatatype{Kind} es una igualdad. Esta se da mediante el predicado \AgdaFunction{Equality} definido más arriba, que es verdadero para ambas bisemejanzas y falso para la desigualdad. Puede parecer a simple vista que esta prueba no es utilizada para demostrar la simetría. Sin embargo, es la presencia de la misma la que hace que no se requiera analizar el caso (\AgdaInductiveConstructor{later$^l$} \{\AgdaInductiveConstructor{geq}\} \AgdaBound{x$\gtrsim$y}) y la prueba aún así sea exhaustiva. Para verlo más claramente se puede agregar este caso, donde se reemplaza la prueba \AgdaBound{eq} por el patrón absurdo, haciendo que no sea necesario dar la definición correspondiente:
 
\ExecuteMetaData[latex/Delay.tex]{symabs}

La transitividad se prueba, al igual que la reflexividad, para todos los tipos de relación \AgdaBound{k}. Esta demostración es un poco más compleja y requiere de tres pruebas separadas que luego se unen. Es por esta razón que se crea un módulo privado \AgdaModule{Trans} que contenga todas las partes de la prueba dentro, donde luego sólo se exporta públicamente la función \AgdaFunction{trans} que constituye la prueba final. Este módulo toma como parámetro una prueba \AgdaBound{trans-$\sim$} de tipo \AgdaFunction{Transitive} \AgdaBound{$\_\sim\_$} que postula la transitividad de la relación subyacente. 

\ExecuteMetaData[latex/Delay.tex]{trans}

La transitividad postula que, dados tres términos \AgdaBound{x}, \AgdaBound{y} y \AgdaBound{z}, si se tienen las relaciones \AgdaDatatype{Rel} \AgdaBound{k x y} y \AgdaDatatype{Rel} \AgdaBound{k y z}, entonces se debe tener también la relación \AgdaDatatype{Rel} \AgdaBound{k x z}. Para demostrar esto, se necesitan dos pruebas auxiliares: \AgdaFunction{now-trans} que prueba esto asumiendo \AgdaBound{z} $=$ (\AgdaInductiveConstructor{now} \AgdaBound{v}) para algún \AgdaBound{v} $:$ \AgdaBound{A} y \AgdaFunction{later-trans} que hace lo mismo para el caso en que \AgdaBound{z} $=$ (\AgdaInductiveConstructor{later} \AgdaBound{z}). Esta última y la prueba principal \AgdaFunction{trans} son mutuamente recursivas y, por lo tanto, se sitúan dentro de un bloque \AgdaKeyword{mutual}.

Se introduce por último la prueba de antisimetría de la relación de desigualdad. Esta postula que, dados dos términos \AgdaBound{x y} $:$ \AgdaBound{A} \AgdaDatatype{$\bot$}, si se tiene que \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y} y \AgdaBound{x} \AgdaFunction{$\lesssim$} \AgdaBound{y}, luego \AgdaBound{x} \AgdaFunction{$\cong$} \AgdaBound{y}, es decir que \AgdaBound{x} e \AgdaBound{y} son fuertemente bisemejantes.

\ExecuteMetaData[latex/Delay.tex]{antisym}

Podría darse también la prueba de antisimetría respecto de la bisemejanza débil, pero esta es trivial puesto que, como se indica en el lema \AgdaFunction{$\gtrsim\Rightarrow$}, basta con sólo una de las relaciones de desigualdad para que \AgdaBound{x} e \AgdaBound{y} sean débilmente bisemejantes. Las pruebas de antisimetría en general tienen sentido cuando la igualdad está incluida en la relación de orden, y no al revés.


\section{Prueba de que el tipo \textit{delay} es una mónada}\label{casodelay:monada}

Ya introducido el tipo \textit{delay} en Agda, se procede ahora a dar la prueba de que este tiene estructura de mónada. Esto se realizará mediante la creación de una instancia del \AgdaKeyword{record} \AgdaRecord{Monad} definido en la sección \ref{funtmon:mon}, cuyo parámetro será el funtor \AgdaFunction{\_$\bot$}. La mónada \textit{delay} puede definirse tanto para la bisemejanza fuerte como para la bisemejanza débil. Se detalla a continuación sólo una de estas pruebas puesto que la otra es análoga. 

Lo primero a definir es el operador \textit{bind}, el cual es común a ambas pruebas y se define como sigue:

\begin{AgdaAlign}
\ExecuteMetaData[latex/Instances/Monad.tex]{bind}

El operador \AgdaFunction{bind} debe tomar un elemento de tipo $\mathit{M} A$ y una función $A \rightarrow \mathit{M} B$. Como en este caso el funtor $\mathit{M}$ está dado por el operador de tipos \AgdaDatatype{\_$\bot$}, los argumentos de \AgdaFunction{bind} serán un término \AgdaBound{t} de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} y una función \AgdaBound{f} de tipo \AgdaBound{A} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$}. En caso de que el primer argumento esté formado por el un termino (\AgdaInductiveConstructor{now} \AgdaBound{x}), el resultado será simplemente aplicar la función \AgdaBound{f} a \AgdaBound{x}. En caso de que el primer argumento sea algo del estilo (\AgdaInductiveConstructor{later} \AgdaBound{x}), el resultado de aplicar \AgdaFunction{bind} será ``meter'' la aplicación hacia adentro del constructor, de manera que la definición es productiva.

La función \AgdaField{return} estará representada por el constructor \AgdaInductiveConstructor{now}, por lo que no es necesario dar una definición de la misma. Este constructor tiene el comportamiento esperado del operador \AgdaField{return}, cuyo sentido usual es encapsular un valor del tipo de retorno dentro de la mónada.

Una vez definidos los operadores básicos, comienza la prueba propiamente dicha. Se analizará la prueba para la bisemejanza débil, la cual se llevará a cabo dentro de un módulo parametrizado llamado \AgdaModule{Weak} que tendrá dos parámetros: una relación binaria \AgdaBound{$\_\sim\_$} $:$ $\forall$ \{\AgdaBound{A}\} $\rightarrow$ \AgdaBound{A} $\rightarrow$ \AgdaBound{A} $\rightarrow$ \AgdaPrimitiveType{Set} y una prueba de que dicha relación es una relación de equivalencia. El objetivo de estos parámetros es fijar una relación de igualdad para los tipos de retorno. 

\ExecuteMetaData[latex/Instances/Monad.tex]{module}

Se demostrarán a continuación las tres leyes de las mónadas. Estas tres pruebas estarán encapsuladas dentro de otro módulo, en este caso anónimo, en el cual se fijará un tipo de retorno particular \AgdaBound{A} con una relación binaria de igualdad sobre el mismo y una prueba de que dicha relación es reflexiva. Este módulo interno sirve principalmente para agrupar los argumentos comunes que tendrán las demostraciones de las tres leyes dentro de él. 

\ExecuteMetaData[latex/Instances/Monad.tex]{props}

Antes de comenzar a demostrar se abren ciertos módulos del tipo \textit{delay} que serán utilizados en las pruebas. Se abre primero el módulo \AgdaModule{Equality}, pasándole la relación \AgdaBound{$\_\sim\_$} sobre \AgdaBound{A} como argumento y extrayendo del mismo la bisemejanza débil (\AgdaFunction{$\_\approx\_$}). Luego se abre el tipo \AgdaKeyword{data} \AgdaDatatype{Rel} para tener acceso a sus constructores. Finalmente, se abre el módulo \AgdaModule{Equivalence} extrayendo de él la prueba \AgdaFunction{refl} de que todas las relaciones (y en particular la bisemejanza débil) son reflexivas. Con todos estos ingredientes la prueba de la primera ley de mónadas queda como sigue:

\ExecuteMetaData[latex/Instances/Monad.tex]{left-identity}

El tipo de la prueba indica que se demuestra que la función \AgdaField{return}, en este caso el constructor \AgdaInductiveConstructor{now}, es neutro a izquierda de \AgdaFunction{bind}. La demostración es trivial ya que la definición de la función \AgdaFunction{bind} establece la igualdad postulada. Seguidamente se expone la demostración de la segunda ley de mónadas:

\ExecuteMetaData[latex/Instances/Monad.tex]{right-identity} 

En este caso se prueba que el constructor \AgdaInductiveConstructor{now} es neutro a derecha de \AgdaFunction{bind}, es decir que para un término \AgdaBound{t} $:$ \AgdaBound{A} \AgdaDatatype{$\bot$}, \AgdaFunction{bind} \AgdaBound{t} \AgdaInductiveConstructor{now} \AgdaFunction{$\approx$} \AgdaBound{t}. En el caso de que \AgdaBound{t} sea de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), la definición de \AgdaFunction{bind} indica que el resultado del lado izquierdo será la aplicación de \AgdaInductiveConstructor{now} a \AgdaBound{x}, quedando una prueba trivial. En caso de tener algo de la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}), así como la definición de \AgdaFunction{bind} es co-recursiva, también lo será la prueba. 

Queda por último la prueba de la tercera ley de mónadas: la asociatividad de \AgdaFunction{bind}. Al igual que en la segunda, el caso base es trivial, mientras que el otro es simplemente co-recursivo. 

\ExecuteMetaData[latex/Instances/Monad.tex]{associative} 

Se cierra entonces el módulo anónimo abierto más arriba y se pasa a definir los elementos faltantes para la prueba. La relación de igualdad será, para cualquier conjunto \AgdaBound{A}, la relación de bisemejanza débil \AgdaFunction{$\_\approx\_$} definida en el módulo \AgdaModule{Equality} con la relación subyacente \AgdaBound{$\_\sim\_$}.

\ExecuteMetaData[latex/Instances/Monad.tex]{eq}

La prueba de que la relación establecida es de equivalencia se construye utilizando las demostraciones de reflexividad, simetría y transitividad presentes en el módulo \AgdaModule{Equivalence}, las cuales requieren la propiedad análoga para la relación subyacente. Las pruebas de estas propiedades análogas se extraen de la prueba \AgdaBound{eq$\sim$}. 

\ExecuteMetaData[latex/Instances/Monad.tex]{equivalence}

Finalmente, habiendo definido todos los componentes necesarios, la instancia de \AgdaRecord{Monad} para el tipo \AgdaDatatype{$\_\bot$} queda como sigue:

\ExecuteMetaData[latex/Instances/Monad.tex]{instance}
\end{AgdaAlign}

Se puede observar que a las pruebas de las tres leyes se les pasa como argumento el parámetro requerido por el módulo anónimo en el cual están encapsuladas. 

La versión de la prueba para la bisemejanza fuerte es análoga a la primera, sólo cambiando la relación de igualdad que se utiliza. El código de la misma se encuentra en el Apéndice \ref{apendice:fuerte}.


\section{Prueba de que el tipo \textit{delay} es un funtor monoidal}\label{casodelay:monoidal}

En esta sección se dotará al tipo \textit{delay} de la estructura de funtor monoidal. El objetivo es acercarse de a poco a la estructura de mónada concurrente, teniendo ya la estructura monádica, el siguiente paso es la estructura monoidal. El primer elemento a definir es entonces la operación binaria que, para el funtor $\mathit{M}$, debe tener tipo $\mathit{M} A \rightarrow \mathit{M} B \rightarrow \mathit{M} (A \times B)$.  En este caso particular, como el funtor $\mathit{M}$ está dado por el operador de tipos \AgdaDatatype{$\_\bot$}, la operación \AgdaField{merge} tendrá el siguiente tipo: \AgdaBound{A} \AgdaDatatype{$\bot$} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$} $\rightarrow$ (\AgdaBound{A} $\times$ \AgdaBound{B}) \AgdaDatatype{$\bot$}.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{merge}

La función \AgdaFunction{merge} se define mediante \textit{pattern matching} sobre los dos argumentos. En el caso de que ambos sean términos de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), el resultado también será un término de la misma forma, donde el valor de retorno será el par formado por los valores de retorno de los argumentos. Cuando uno de los dos es de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}) y el otro es de la forma (\AgdaInductiveConstructor{later} \AgdaBound{y}), el resultado se construye con un constructor \AgdaInductiveConstructor{later} que dentro tiene una llamada co-recursiva suspendida. El término que tenía el constructor \AgdaInductiveConstructor{later} ya no lo tiene, haciendo productiva la co-recursión, mientras que el que tenía el constructor \AgdaInductiveConstructor{now} queda igual. En caso de que ambos términos estén formados por un constructor \AgdaInductiveConstructor{later}, también se realiza una llamada co-recursiva, donde ambos términos se achican, y por fuera sólo queda un único constructor \AgdaInductiveConstructor{later} en lugar de dos. Esto se debe a que \AgdaFunction{merge}, intuitivamente, representa el paralelismo de dos computaciones, por lo que ambos \AgdaInductiveConstructor{later} se fusionan en uno que realiza internamente el resto de ambas computaciones en paralelo (gracias a la llamada co-recursiva de \AgdaFunction{merge}).

El siguiente operador a definir es \AgdaField{fmap}, el cual representa, como se mencionó en la sección \ref{funtmon:funt}, la asignación de morfismos del funtor que en este caso está dado por \AgdaDatatype{$\_\bot$}. Este operador, por lo tanto, asignará, para cada función \AgdaBound{A} $\rightarrow$ \AgdaBound{B}, una función \AgdaBound{A} \AgdaDatatype{$\bot$} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$}. 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{fmap}

Dada la función \AgdaBound{f} $:$ \AgdaBound{A} $\rightarrow$ \AgdaBound{B}, si el elemento de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} recibido es de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), entonces el resultado de aplicar \AgdaFunction{fmap} \AgdaBound{f} a tal elemento es un término construído también con \AgdaInductiveConstructor{now}, donde el valor de retorno será la aplicación de \AgdaBound{f} al valor de retorno del argumento. En caso de que el argumento tenga la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}), el resultado de la aplicación de \AgdaFunction{fmap} \AgdaBound{f} a tal término estará formado también por un constructor \AgdaInductiveConstructor{later} que dentro propaga la aplicación de \AgdaFunction{fmap} \AgdaBound{f} al término (\AgdaField{$\flat$} \AgdaBound{x}). 

Queda por definir el operador 0-ario \AgdaField{unit}. Este se definió en la formalización como un elemento de tipo \AgdaBound{M} \AgdaDatatype{$\top$}. En el caso del tipo \textit{delay}, será un habitante del tipo \AgdaDatatype{$\top$ $\bot$}. Se define entonces \AgdaFunction{unit} como el elemento más simple de tal tipo:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{unit}

Definidos estos tres operadores, lo que sigue son las demostraciones de las propiedades. La prueba de que el tipo \textit{delay} es un funtor monoidal puede darse, al igual que la de mónada, tanto para la bisemejanza fuerte como para la débil, sinendo ambas pruebas análogas. Se detalla entonces la versión de la bisemejanza débil. Esta prueba se dará dentro de un módulo llamado \AgdaModule{Weak} que recibirá como parámetro la relación de igualdad subyacente junto con una prueba de que es una relación de equivalencia. 

\begin{AgdaAlign}
\ExecuteMetaData[latex/Instances/Monoidal.tex]{module}

La primera propiedad que se demostrará será la asociatividad del operador \AgdaFunction{merge}. Esta se da dentro de un módulo anónimo en el cual se fija como tipo de retorno el producto cartesiano de tres conjuntos \AgdaBound{A}, \AgdaBound{B} y \AgdaBound{C}. Este módulo requiere como parámetro una relación de igualdad entre elementos de este conjunto y la prueba de que la misma es reflexiva. Dentro del módulo se abre, primero, el módulo \AgdaModule{Equality} para el conjunto de retorno \AgdaBound{A} \AgdaDatatype{$\times$} \AgdaBound{B} \AgdaDatatype{$\times$} \AgdaBound{C} con la igualdad subyacente recibida como argumento, del cual se extrae la relación de bisemejanza débil \AgdaFunction{$\_\approx\_$}. Luego se abre el tipo \AgdaDatatype{Rel} de manera que puedan usarse sus constructores sin prefijo. 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{associative}

La prueba no presenta mayores dificultades. En el caso base, donde los tres términos son de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), las aplicación (\AgdaFunction{merge} (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{a}) (\AgdaInductiveConstructor{now} \AgdaBound{b})) (\AgdaInductiveConstructor{now} \AgdaBound{c})) genera el siguiente término: (\AgdaInductiveConstructor{now} ((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c})). Al aplicar \AgdaFunction{fmap} (\AgdaSymbol{$\lambda \{$}((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c})\AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) a este resultado, se obtiene el término (\AgdaInductiveConstructor{now} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))), el cual es también el resultado de la aplicación del lado derecho de la ecuación: (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{a}) (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{b}) (\AgdaInductiveConstructor{now} \AgdaBound{c}))), por lo que la prueba queda trivial. En los demás casos, la prueba se resuelve con una llamada co-recursiva, donde los términos de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}) quedan igual, mientras que los que se componen de un constructor \AgdaInductiveConstructor{later} se achican.

Para la prueba del neutro a derecha del operador \AgdaFunction{merge}, se define otro módulo anónimo en el que la relación de igualdad pedida como parámetro y su respectiva prueba de que la relación dada es reflexiva deben estar definidas para elementos del conjunto \AgdaBound{A} \AgdaDatatype{$\times$ $\top$}, para algún conjunto \AgdaBound{A}. Dentro de este módulo se abren también el módulo \AgdaModule{Equality} y el tipo \AgdaDatatype{Rel} para el mismo conjunto.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{rid}

Para el caso en el que \AgdaBound{a} tiene la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), la aplicación (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{x}) \AgdaFunction{unit}) tiene como resultado el término (\AgdaInductiveConstructor{now} (\AgdaBound{x} \AgdaInductiveConstructor{, tt})). Aplicar \AgdaFunction{fmap} (\AgdaSymbol{lambda} \AgdaBound{a} $\rightarrow$ (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) a (\AgdaInductiveConstructor{now} \AgdaBound{x}) tiene el mismo resultado, por lo que la prueba de este caso es trivial. El otro caso se resuelve, al igual, que antes con una llamada co-recursiva. 

La prueba del neutro a izquierda de \AgdaFunction{merge} es análoga a la anterior, donde el módulo anónimo en el cual se encapsula es análogo también:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{lid}

Los elementos faltantes son la relación de igualdad para términos de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}, para cualquier conjunto \AgdaBound{A}, y la prueba correspondiente de que tal relación es de equivalencia. La definición de estos elementos es igual a la construída para la estructura de mónada.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{eq}

Finalmente, la instancia de \AgdaRecord{MonoidalFunctor} para el operador de tipos \AgdaDatatype{$\_\bot$} queda como sigue:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{instance}
\end{AgdaAlign} 

La estructura de funtor monoidal para la bisemejanza fuerte es análoga a la anterior. El código de la misma se encuentra en el Apéndice \ref{apendice:fuerte}. 

\section{¿El tipo \textit{delay} es una mónada concurrente?}\label{casodelay:concmonad}

El objetivo de esta sección es (intentar) demostrar que el tipo \textit{delay} es una mónada concurrente. Como se detallará más adelante, la mayor parte de esta prueba es similar a las dos presentadas anteriormente. La dificultad está principalmente en el último campo: la ley de intercambio. 

Una diferencia sustancial con las pruebas anteriores es que, en este caso, no es posible dar la instancia de \AgdaRecord{ConcurrentMonad} para el tipo \textit{delay} utilizando como igualdad la bisemejanza débil. Esto se debe a que la relación de orden debe ser, entre otras cosas, reflexiva respecto de la igualdad. Es decir que si se tienen dos valores \AgdaBound{x} e \AgdaBound{y} tales que \AgdaBound{x} $\sim$ \AgdaBound{y} (son iguales según la relación de igualdad considerada), entonces se debe cumplir que estos valores también están relacionados por la relación de orden, o sea que \AgdaBound{x} $\lesssim$ \AgdaBound{y}. Esto no es cierto para la desigualdad definida para el tipo \AgdaDatatype{$\_\bot$} respecto de la bisemejanza débil ya que, como se mencionó en la sección \ref{casodelay:defmus}, la bisemejanza débil es la relación más flexible de las tres que se introdujeron. Por lo tanto, la prueba se realizará únicamente para la bisemejanza fuerte. 

Otro cambio respecto de las pruebas ya presentadas es que no se considerará en esta una igualdad parametrizada para los tipos de retorno como se hizo anteriormente. Esta decisión se debe a que en varias demostraciones, principalmente las que tienen que ver con la relación de orden, fue necesario realizar \textit{pattern matching} sobre la igualdad de dos valores de retorno, de manera que se unifiquen dos variables si estas son iguales. Esto sólo es posible \textit{a priori} para la igualdad proposicional, por lo que se desarrolló la prueba en cuestión tomando dicha relación como igualdad en los tipos de retorno. Si bien se pierde algo de generalidad, lo más importante es que se conserva la igualdad parametrizada para el tipo \textit{delay} que es coinductivo, ya que esta clase de tipos es la que tiene más problemas con la igualdad proposicional.

Se importa entonces el módulo de la igualdad proposicional, renombrando \AgdaInductiveConstructor{refl}, \AgdaFunction{sym} y \AgdaFunction{trans} agregando una \textbf{p} delante, de manera que no haya conflicto de nombres con las propiedades demostradas en el módulo \AgdaModule{Equality} que llevan los mismos nombres. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{propeq} 

Los operadores que se utlizarán son los mismos que se definieron en las secciones anteriores: \AgdaFunction{bind} y \AgdaFunction{return} para la estructura monádica y \AgdaFunction{merge} y \AgdaFunction{unit} $=$ \AgdaInductiveConstructor{now tt} para la estructura monoidal. Es preciso notar que la definición de \AgdaFunction{unit} dada para la instancia de funtor monoidal se puede reutilizar en esta sección debido a que coincide con la expresión \AgdaFunction{return} \AgdaInductiveConstructor{tt}, puesto que \AgdaFunction{unit} no es un campo a definir sino que es una constante del \AgdaKeyword{record} \AgdaRecord{ConcurrentMonad}.

Al igual que antes, se desarrolla la prueba dentro de un módulo llamado, en este caso, \AgdaModule{Strong}, el cual no estará parametrizado ya que, como se explicó, se utilizará la igualdad proposicional para los tipos de retorno. 

\begin{AgdaAlign}
\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{module}

Las primeras propiedades que se demuestran son las leyes de las mónadas. Estas se encapsulan dentro de un módulo anónimo que está parametrizado por un conjunto \AgdaBound{A} $:$ \AgdaPrimitiveType{Set} de retorno. Antes de realizar las pruebas se abre el módulo \AgdaModule{Equality}  para el conjunto \AgdaBound{A} tomando como igualdad en este conjunto la igualdad proposicional (\AgdaFunction{\_$\equiv$\_}) y extrayendo del mismo la relación de bisemejanza fuerte. Luego se abre \AgdaModule{Equality.Rel} para poder utilizar sus constructores y, finalmente, se abre el módulo \AgdaModule{Equivalence} para utilizar la reflexividad de la bisemejanza fuerte. Las demostraciones son análogas a las realizadas en la sección \ref{casodelay:monada}, cambiando únicamente en los casos triviales la reflexividad utilizada. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{bindprops}

Luego de las propiedades del operador \AgdaFunction{bind}, se demuestra su compatibilidad con la relación de orden. Para ello se crea otro módulo anónimo que tiene dos parámetros, \AgdaBound{A} y \AgdaBound{B} de tipo \AgdaPrimitiveType{Set}. Antes de realizar la prueba se abre el módulo \AgdaModule{Equality} para cada uno de los conjuntos de retorno, utilizando para ambos la igualdad proposicional y renombrando los términos a utilizar de manera que no haya conflicto de nombres. Finalmente, se abre \AgdaModule{Equality.Rel}, renombrando \AgdaInductiveConstructor{later$^l$} como \AgdaInductiveConstructor{$\lesssim$later$^l$}. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{bindcomp}

La prueba toma dos valores \AgdaBound{a$_1$} y \AgdaBound{a$_2$} de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}, dos funciones \AgdaBound{f$_1$} y \AgdaBound{f$_2$} de tipo \AgdaBound{A} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$}, una prueba de que \AgdaBound{a$_1$} \AgdaFunction{$\lesssim$A} \AgdaBound{a$_2$} y una prueba de que para cualquier \AgdaBound{a} $:$ \AgdaBound{A} se cumple que \AgdaBound{f$_1$ a} \AgdaFunction{$\lesssim$B} \AgdaBound{f$_2$ a}, es decir que \AgdaBound{f$_1$} $\lesssim$ \AgdaBound{f$_2$}. 

En el caso base, donde ambos valores son de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), al hacer \textit{pattern matching} sobre la prueba \AgdaBound{a$_1\lesssim$a$_2$}, se obtiene que está dada por el término (\AgdaInductiveConstructor{now prefl}), lo cual hace que, obligatoriamente, el valor de retorno del segundo argumento sea igual al del primero. El objetivo es ver que \AgdaFunction{bind} (\AgdaInductiveConstructor{now} \AgdaBound{a$_1$}) \AgdaBound{f$_1$} \AgdaFunction{$\lesssim$B} \AgdaFunction{bind} (\AgdaInductiveConstructor{now} \AgdaBound{a$_2$}) \AgdaBound{f$_2$}, lo cual por definición es lo mismo que escribir: \hbox{\AgdaBound{f$_1$ a$_1$} \AgdaFunction{$\lesssim$B} \AgdaBound{f$_2$ a$_2$}}. Aquí se evidencia la necesidad de poder unificar ambos valores a la misma variable, puesto que la prueba \AgdaBound{f$_1\lesssim$f$_2$} sólo puede usarse si se trata del mismo valor \AgdaBound{a} $:$ \AgdaBound{A}. Gracias al patrón con punto dado por el \textit{pattern matching} de \AgdaInductiveConstructor{prefl}, ambos valores de retorno son \AgdaBound{a$_1$} y el objetivo es probar que \AgdaBound{f$_1$ a$_1$} \AgdaFunction{$\lesssim$B} \AgdaBound{f$_2$ a$_1$}, lo cual se demuestra aplicando la prueba \AgdaBound{f$_1\lesssim$f$_2$} al valor \AgdaBound{a$_1$} $:$ \AgdaBound{A}. 

En el segundo caso, el primer argumento es (\AgdaInductiveConstructor{now} \AgdaBound{a$_1$}), y el segundo, (\AgdaInductiveConstructor{later} \AgdaBound{a$_2$}). La prueba de que el primero es menor o igual al segundo está dada por el constructor \AgdaInductiveConstructor{$\lesssim$later$^l$} junto con una prueba \AgdaBound{a$_1\lesssim$a$_2$} de tipo (\AgdaInductiveConstructor{now} \AgdaBound{a$_1$}) \AgdaFunction{$\lesssim$B} (\AgdaField{$\flat$} \AgdaBound{a$_2$}). Puede parecer a simple vista que el constructor es erróneo, pero en el módulo \AgdaModule{Equality} se define la relación de menor o igual como la relación inversa del mayor o igual, por lo que los constructores quedan ``invertidos''. El constructor \AgdaInductiveConstructor{$\lesssim$later$^l$} hace referencia en realidad al término (\AgdaInductiveConstructor{later} \AgdaBound{a$_2$}) \AgdaFunction{$\gtrsim$B} (\AgdaInductiveConstructor{now} \AgdaBound{a$_1$}). La prueba en este caso se reduce a utilizar el mismo constructor con una llamada co-recursiva dentro, en la cual el primer argumento queda igual y el segundo se ``achica''. La prueba de que el primero es menor o igual al segundo está dada por la variable \AgdaBound{a$_1\lesssim$a$_2$} que, como se mencionó antes, tiene el tipo correcto. Las funciones y la prueba de su relación quedan iguales.

En los dos últimos casos los primeros dos argumentos son de la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}). No podría darse el caso de que el primero esté construído con \AgdaInductiveConstructor{later} y el segundo se construya con \AgdaInductiveConstructor{now} puesto que no habría manera de dar una prueba de que el primero es menor o igual al segundo. Luego la prueba es exhaustiva aunque no contemple este caso. La diferencia entre el penúltimo y el último caso está en la prueba de desigualdad entre los primeros argumentos. En el primero esta prueba está dada por un constructor \AgdaInductiveConstructor{later} con una prueba \AgdaBound{a$_1\lesssim$a$_2$} de tipo \AgdaFunction{$\infty$} ((\AgdaField{$\flat$} \AgdaBound{a$_1$}) \AgdaFunction{$\lesssim$B} (\AgdaField{$\flat$} \AgdaBound{a$_2$})). En este caso la demostración se realiza con el mismo constructor y dentro de él una llamada co-recursiva (suspendida) donde los dos primeros argumentos se ``achican'' y la prueba de que el primero es menor o igual al segundo está dada por (\AgdaField{$\flat$} \AgdaBound{a$_1\lesssim$a$_2$}). Una vez más las funciones y su relación quedan iguales. 

En el último caso, la prueba de que (\AgdaInductiveConstructor{later} \AgdaBound{a$_1$}) es menor o igual a (\AgdaInductiveConstructor{later} \AgdaBound{a$_2$}) está dada por el constructor \AgdaInductiveConstructor{$\lesssim$later$^l$} y una prueba \AgdaBound{a$_1\lesssim$a$_2$} de tipo ((\AgdaInductiveConstructor{later} \AgdaBound{a$_1$}) \AgdaFunction{$\lesssim$B} (\AgdaField{$\flat$} \AgdaBound{a$_2$})). La demostración de este caso será similar a la del anterior, donde se utiliza el constructor \AgdaInductiveConstructor{later} y los dos primeros argumentos se ``achican''. La diferencia está en que, en este caso, no se puede utilizar directamente la prueba \AgdaBound{a$_1\lesssim$a$_2$} puesto que esta debería tener tipo ((\AgdaField{$\flat$} \AgdaBound{a$_1$}) \AgdaFunction{$\lesssim$B} (\AgdaField{$\flat$} \AgdaBound{a$_2$})) en lugar de ((\AgdaInductiveConstructor{later} \AgdaBound{a$_1$}) \AgdaFunction{$\lesssim$B} (\AgdaField{$\flat$} \AgdaBound{a$_2$})), por lo que tiene un constructor \AgdaInductiveConstructor{later} en el lado izquierdo que sobra. Esto se soluciona aplicando la función \AgdaFunction{later$^{r-1}$} a la prueba para quitar el constructor de más (una vez más se debe recordar que los lados se invierten porque la relación de base es mayor o igual).

Una vez demostradas todas las propiedades del operador \AgdaFunction{bind}, se pasa a demostrar las correspondientes al operador \AgdaFunction{merge}. Estas pruebas serán similares a las dadas para \AgdaRecord{MonoidalFunctor}, salvo que en este caso no se utilizará \AgdaFunction{fmap} sino su equivalente construído a partir de \AgdaFunction{bind}, como se explicó en la sección \ref{form:monconc}. Antes de pasar a las propiedades, se demostrará la equivalencia entre ambas expresiones de manera que no queden dudas de que las propiedades del campo \AgdaField{merge} están bien definidas. La demostración no presenta mayores dificultades.

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{fmapbind} 

La primera propiedad de \AgdaFunction{merge} que se demuestra es su asociatividad, para la cual se crea un módulo anónimo con tres argumentos implícitos que son los tres conjuntos, \AgdaBound{A}, \AgdaBound{B} y \AgdaBound{C}, que se utilizan en la prueba. Antes de demostrar esta propiedad se abre el módulo \AgdaModule{Equality}, esta vez para el producto cartesiano de los tres conjuntos mencionados, tomando como igualdad en el producto la igualdad proposicional y extrayendo del módulo la relación de bisemejanza fuerte. Al igual que antes se abre también \AgdaModule{Equality.Rel}.

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergeassoc}

El tipo de la prueba se corresponde con el tipo del campo \AgdaField{assoc}, el cual se obtiene como se explicó en la sección \ref{form:monconc}. La demostración es, en esencia, igual a la introducida en la sección \ref{casodelay:monoidal} para \AgdaRecord{MonoidalFunctor}. El único cambio es la reflexividad de la relación de los tipos de retorno que, en este caso, pasa a ser \AgdaInductiveConstructor{prefl}. 

Las demostraciones de que (\AgdaInductiveConstructor{now tt}) es neutro a izquierda y derecha respecto de \AgdaFunction{merge} también son iguales a las probadas para \AgdaRecord{MonoidalFunctor}. Los únicos cambios son la igualdad con la que se abre el módulo \AgdaModule{Equality} y la reflexividad que se utiliza en el caso base. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergerid}

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergelid}

Al igual que con el operador \AgdaFunction{bind}, se debe demostrar la compatibilidad de \AgdaFunction{merge} con la relación de orden. Esto se realiza dentro de un módulo anónimo que toma como argumentos dos conjuntos, \AgdaBound{A} y \AgdaBound{B}. Se abre el módulo \AgdaModule{Equality} para tres conjuntos distintos: \AgdaBound{A}, \AgdaBound{B} y \AgdaBound{A} $\times$ \AgdaBound{B}. En los tres casos se utiliza la igualdad proposicional, en los primeros dos se renombran los elementos a utilizar para que no haya conflictos de nombre. Finalmente se abre \AgdaModule{Equality.Rel} renombrando el constructor \AgdaInductiveConstructor{later$^l$} como \AgdaInductiveConstructor{$\lesssim$later$^l$} por la misma razón.

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergecomp}

Esta prueba toma cuatro valores: \AgdaBound{a$_1$} y \AgdaBound{a$_2$} de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} y \AgdaBound{b$_1$} y \AgdaBound{b$_2$} de tipo \AgdaBound{B} \AgdaDatatype{$\bot$}. Además toma dos pruebas: una demuestra que \AgdaBound{a$_1$} es menor o igual a \AgdaBound{a$_2$} y la otra que \AgdaBound{b$_1$} es menor o igual a \AgdaBound{b$_2$}. Cada uno de los cuatro valores puede tener dos formas, (\AgdaInductiveConstructor{now} \AgdaBound{x}) o (\AgdaInductiveConstructor{later} \AgdaBound{x}), y las dos pruebas pueden estar dadas de tres formas distintas: (\AgdaInductiveConstructor{now} \AgdaBound{x$\sim$}), (\AgdaInductiveConstructor{later} \AgdaBound{x$\lesssim$}) y (\AgdaInductiveConstructor{$\lesssim$later$^l$} \AgdaBound{x$\lesssim$}), salvo por algunas pocas combinaciones que no son posibles. Esto hace que la prueba tenga muchos casos y explicar uno por uno sea muy largo y tedioso. Se detallan a continuación algunos lineamientos generales:
\begin{itemize}[noitemsep]
\item En el caso base se puede observar cómo, una vez más, se hace uso del \textit{pattern matching} en \AgdaInductiveConstructor{prefl} para unificar variables y resolver, en este caso, la igualdad en el producto cartesiano. Si se tuviera una igualdad parametrizada para el conjunto \AgdaBound{A}, otra para el conjunto \AgdaBound{B} y otra para \AgdaBound{A} $\times$ \AgdaBound{B}, no se podría deducir la igualdad del producto cartesiano a partir de las igualdades individuales. 

\item El resto de los casos se resuelve con uno de los constructores no básicos, \AgdaInductiveConstructor{later} o \AgdaInductiveConstructor{$\lesssim$later$^l$}, y una llamada co-recursiva dentro. 

\item En las llamadas co-recursivas todos los valores que tenían la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}) se reducen a (\AgdaField{$\flat$} \AgdaBound{x}), sin importar qué forma tenga la prueba de desigualdad que lo involucra. 

\item En los casos en los que, por la forma de la prueba de desigualdad, sobra un constructor \AgdaInductiveConstructor{later} en uno de los lados para poder utilizar la prueba en la llamada co-recursiva, se utiliza la función \AgdaFunction{later$^{r-1}$} para solucionarlo al igual que en la prueba de compatibilidad del \AgdaFunction{bind}.
\end{itemize}

Queda por demostrar una última propiedad para el operador \AgdaFunction{merge}: la conmutatividad. Esta es requerida para que el funtor monoidal agregado a la mónada sea simétrico y se demuestra dentro del mismo módulo anónimo que la propiedad anterior ya que requiere los mismos conjuntos. La prueba es bastante simple, el caso base es trivial y los demás casos se resuelven simplemente utilizando el constructor \AgdaInductiveConstructor{later} con una llamada co-recursiva suspendida dentro. En las llamadas co-recursivas los términos del tipo (\AgdaInductiveConstructor{now} \AgdaBound{x}) quedan igual y los que tienen la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}) se reducen a (\AgdaField{$\flat$} \AgdaBound{x}).

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergecomm}

Se definen a continuación las relaciones de igualdad y orden. Estas son extraídas del módulo \AgdaModule{Equality} utilizando como igualdad subyacente la igualdad proposicional. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{rels}

Una vez definidas ambas relaciones, se prueba que estas son una relación de equivalencia y un orden parcial, respectivamente. Para esto se incluyen del módulo \AgdaModule{Equivalence} las pruebas \AgdaFunction{refl} y \AgdaFunction{trans} que prueban la reflexividad y transitividad para ambas relaciones, \AgdaFunction{sym} que prueba la simetría de la igualdad y \AgdaFunction{antisym} que prueba la antisimetría del orden. La prueba de que la bisemejanza fuerte es una relación de equivalencia es similar a las explicadas en las secciones anteriores, con la diferencia de que la reflexividad, simetría y transitividad de la igualdad subyacente están dadas ahora por las pruebas correspondientes de la igualdad proposicional importadas del módulo \AgdaModule{Relation.Binary.PropositionalEquality}.

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{eqpartial}

La prueba de que la relación de orden es un orden parcial se realiza respecto de la relación de igualdad. Esta consta de dos partes: la primera prueba que es un preorden y la segunda agrega la antisimetría. La prueba de que es un preorden requiere, primero, una prueba de que la relación de igualdad es una relación de equivalencia, para lo cual se utiliza la prueba \AgdaFunction{eq$\cong\bot$} realizada previamente. 

Luego se pide la reflexividad en términos de la relación de igualdad establecida, es decir que se pide que la relación \AgdaFunction{$\cong\bot$} implique la relación \AgdaFunction{$\lesssim\bot$}. Esta prueba está dada por el término \AgdaFunction{$\cong\bot\Rightarrow\lesssim\bot$}. En el caso base la prueba de igualdad está dada por el constructor \AgdaInductiveConstructor{Equality.now} y una prueba \AgdaBound{nowx$\sim$nowy} de que \AgdaBound{x} \AgdaFunction{$\equiv$} \AgdaBound{y}. Para dar la prueba de la desigualdad, no se da la prueba de que (\AgdaInductiveConstructor{now} \AgdaBound{x}) \AgdaFunction{$\lesssim$} (\AgdaInductiveConstructor{now} \AgdaBound{y}), sino que se prueba que (\AgdaInductiveConstructor{now} \AgdaBound{y}) \AgdaFunction{$\gtrsim$} (\AgdaInductiveConstructor{now} \AgdaBound{x}), puesto que el menor o igual se define en términos del mayor o igual. Por lo tanto, se requiere una prueba de que \AgdaBound{y} \AgdaFunction{$\equiv$} \AgdaBound{x}, la cual se obtiene aplicando la simetría de la igualdad proposicional a la prueba \AgdaBound{nowx$\sim$nowy}. El otro caso se resuelve co-recursivamente. 

La última prueba pedida para que la relación sea un preorden es la transitividad. La prueba \AgdaFunction{trans}, importada del módulo \AgdaModule{Equivalence}, prueba la transitividad para el mayor o igual, es decir que si \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y} e \AgdaBound{y} \AgdaFunction{$\gtrsim$} \AgdaBound{z} entonces \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{z}. Esto en términos del menor o igual es equivalente a decir que si \AgdaBound{y} \AgdaFunction{$\lesssim$} \AgdaBound{x} y \AgdaBound{z} \AgdaFunction{$\lesssim$} \AgdaBound{y} entonces \AgdaBound{z} \AgdaFunction{$\lesssim$} \AgdaBound{x}. Como se puede observar, esto no es exactamente la definicion de transitividad, puesto que las hipótesis deberían estar al revés, lo cual se soluciona aplicando \AgdaFunction{flip} a la prueba de transitividad dada como se realiza en \AgdaFunction{trans$\lesssim\bot$}.

A la hora de probar la antisimetría, por último, sucede algo similar que hace necesario aplicar \AgdaFunction{flip} a la prueba de antisimetría dada puesto que cambia el orden en que se toman las pruebas de desigualdad respecto del orden en que se toman los argumentos implícitos que son los valores sobre los cuales se realizan las pruebas de desigualdad. En \AgdaFunction{antisym$\lesssim\bot$} se realiza este cambio y queda así concluída la prueba de que la relación de orden es un orden parcial. 

Con todas las demostraciones realizadas hasta esta parte, se puede generar la instancia de \AgdaRecord{ConcurrentMonad} \AgdaDatatype{$\_\bot$}, quedando únicamente el hueco para la prueba de la ley de intercambio. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{instance}

A la hora de intentar probar la ley de intercambio, empezaron a surgir varios problemas. A continuación se muestran varias pruebas que se fueron realizando y lemas que se fueron definiendo en el intento de poder demostrarlo. Estos intentos fueron realizados dentro de un módulo anónimo que toma como parámetros implícitos cuatro conjuntos. Dentro de él se abre el módulo \AgdaModule{Equality} para tres conjuntos distintos, \AgdaBound{C}, \AgdaBound{D} y \AgdaBound{C} $\times$ \AgdaBound{D}, haciendo los renombres correspondientes. Al igual que antes también se abren \AgdaModule{Equality.Rel} renombrando el constructor \AgdaInductiveConstructor{later$^l$} y el módulo \AgdaModule{Equivalence}.

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{ichangemodule}

Los primeros tres lemas prueban propiedades básicas cuya necesidad surgió en el proceso de intentar probar la ley de intercambio. \AgdaFunction{merge-ext} prueba que, si se tienen cuatro valores, \AgdaBound{c$_1$} y \AgdaBound{c$_2$} de tipo \AgdaBound{C} \AgdaDatatype{$\bot$} y \AgdaBound{d$_1$} y \AgdaBound{d$_2$} de tipo \AgdaBound{D} \AgdaDatatype{$\bot$}, tales que \AgdaBound{c$_1$} \AgdaFunction{$\cong$C} \AgdaBound{c$_2$} y \AgdaBound{d$_1$} \AgdaFunction{$\cong$D} \AgdaBound{d$_2$}, entonces se cumple que \hbox{\AgdaFunction{merge} \AgdaBound{c$_1$ d$_1$} \AgdaFunction{$\gtrsim$} \AgdaFunction{merge} \AgdaBound{c$_2$ d$_2$}}. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{mergeext}

Las dos propiedades que siguen prueban que si dos términos son iguales según la igualdad proposicional, entonces deben ser también iguales según la bisemejanza fuerte. Se realizan dos pruebas por separado para cada tipo de retorno que fue necesario ya que la bisemejanza fuerte con cada tipo de retorno está nombrada de una manera diferente. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{equivimplicancias}

Se muestra a continuación el intento de prueba de la ley de intercambio, en el cual se utilizan dos lemas que se describirán luego. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{interchange}

Si se observa la prueba, se puede ver que en el segundo caso se abre con una sentencia \AgdaKeyword{with} el término \AgdaBound{f a}, de manera que se puedan analizar los diferentes resultados posibles de la aplicación. Al intentar resolver estos casos, surge un problema ya que Agda no logra unificar, en el primer caso, por ejemplo, el término \AgdaBound{f a} con \AgdaInductiveConstructor{now} \AgdaBound{x}. Si bien ambos términos son iguales por definición de la expresión \AgdaKeyword{with}, en el objetivo a demostrar de ese caso aparece de un lado de la desigualdad la expresión \AgdaBound{f a} y, del otro, \AgdaInductiveConstructor{now} \AgdaBound{x}. En el intento de solucionar este problema, se agrega a la cláusula \AgdaKeyword{with} el término \AgdaFunction{inspect} \AgdaBound{f a} que lo que hace cuando uno realiza \textit{pattern matching} sobre el mismo es dar una prueba de que los términos en cuestión son iguales. Así se crea el \AgdaFunction{lema$_1$} en el intento de demostrar ese caso específico. En su tipo se puede observar cómo, de un lado de la desigualdad, aparece el término \AgdaBound{f a} y, del otro, \AgdaInductiveConstructor{now} \AgdaBound{x}, y se pide como argumento una prueba de que estos dos términos son iguales (según la igualdad proposicional ya que es lo que provee \AgdaFunction{inspect}). En la prueba del \AgdaFunction{lema$_1$} se utilizan los tres lemas anteriores. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{lemas}
\end{AgdaAlign}

El \AgdaFunction{lema$_2$} es también un caso particular de \AgdaFunction{interchange}: el caso en que \AgdaBound{f a} da como resultado \AgdaInductiveConstructor{later} \AgdaBound{y}. En el intento de probar este segundo lema, vuelve a surgir el mismo problema al intentar inspeccionar con \AgdaKeyword{with} el término \AgdaField{$\flat$} \AgdaBound{y}. De esta manera, la prueba se empezó a complejizar cada vez más, evidenciando un problema de base en el soporte para coinducción con notación musical. 

Luego de batallar bastante se obtuvieron los siguientes ejemplos, en los cuales se puede observar el problema real de fondo. 

\ExecuteMetaData[latex/Instances/ConcurrentMonad.tex]{problems}

El primer lema, \AgdaFunction{$\equiv\sharp\flat$}, prueba que los operadores \AgdaField{$\flat$} y \AgdaCoinductiveConstructor{$\sharp$} son opuestos en el sentido de que si se tiene un \AgdaBound{s} $:$ \AgdaBound{S} \AgdaDatatype{$\bot$}, se lo suspende con \AgdaCoinductiveConstructor{$\sharp$} y luego se lo desencapsula con \AgdaField{$\flat$}, se obtiene como resultado el término inicial. La prueba de este lema es trivial. Al intentar probar el lema complementario, \AgdaFunction{$\equiv\flat\sharp$}, que toma un \AgdaBound{s} $:$ \AgdaFunction{$\infty$} (\AgdaBound{S} \AgdaDatatype{$\bot$}) y postula que (\AgdaCoinductiveConstructor{$\sharp$} (\AgdaField{$\flat$} \AgdaBound{s})) \AgdaFunction{$\equiv$} \AgdaBound{s}, surgen los problemas. Agda no acepta la prueba trivial y, al observar el tipo objetivo de la prueba en el modo interactivo, aparece lo siguiente: \AgdaHole{Instances.ConcurrentMonad.♯-54 s ≡ s}. Se evidencia entonces que hay problemas a la hora de igualar elementos construídos con \AgdaCoinductiveConstructor{$\sharp$}. Más aún, en el tercer lema, \AgdaFunction{$\equiv\Rightarrow\sharp\equiv$}, se intenta probar que si se tienen dos términos, \AgdaBound{s$_1$} y \AgdaBound{s$_2$}, que son iguales según la igualdad proposicional, entonces los resultados de aplicar \AgdaCoinductiveConstructor{$\sharp$} a ambos términos también son iguales según la misma igualdad. Una vez más Agda no acepta la prueba trivial y el tipo objetivo que se observa en el modo interactivo es: \AgdaHole{Instances.ConcurrentMonad.♯-56 s₁ s₁ ≡ Instances.ConcurrentMonad.♯-57 s₁ s₁}. Con estos ejemplos se evidencia que esta notación, en particular el operador \AgdaCoinductiveConstructor{$\sharp$}, tiene problemas para deducir la igualdad de los términos, es como si hubiera diferentes tipos de \AgdaCoinductiveConstructor{$\sharp$}, con diferentes números cada uno. 

\section{Reduciendo el problema a los conaturales}\label{casodelay:conat}

Los números conaturales pueden verse como una versión simplificada del tipo \textit{delay} en la que no hay un tipo de retorno, o bien, este tipo es \AgdaDatatype{$\top$}, el cual tiene un único habitante. Así, cada constructor \AgdaInductiveConstructor{later} se correspondería con un constructor \AgdaInductiveConstructor{suc}. 

A raíz de las dificultades encontradas en el intento de probar la ley de intercambio para la mónada \textit{delay}, se decidió simplificar el problema e intentar probar la ley de intercambio para los números conaturales, en este caso la ley a demostrar sería la ley de intercambio de los monoides concurrentes. El objetivo de esta simplificación es ver si el problema para reconocer términos iguales se debe al valor que (posiblemente) retornan los términos de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} o si el problema está en el soporte para coinducción utilizado.

\subsection{Definición de los conaturales con notación musical}\label{casodelay:conat:defmus}

En la sección \ref{coind:agda:musical} se introdujo la siguiente definición para los números conaturales:
\ExecuteMetaData[latex/ConaturalsM.tex]{def}

Se definen para el tipo dado dos relaciones: una de igualdad, a la cual se la llamará bisemejanza, y la otra de orden. Como se puede observar, estas relaciones se definen de manera análoga a las relaciones de bisemejanza fuerte y desigualdad definidas para el tipo \textit{delay}. 
\ExecuteMetaData[latex/ConaturalsM.tex]{rels}

A continuación se prueba que la relación de igualdad definida es una relación de equivalencia, es decir que es reflexiva simétrica y transitiva. Las demostraciones de tales propiedades son bastante simples, los casos base son triviales y los demás se resuelven mediante co-recursión.
\ExecuteMetaData[latex/ConaturalsM.tex]{equiv}

Siendo la igualdad una relación de equivalencia, se prueba seguidamente que la relación de orden es un orden parcial respecto de la bisemejanza. Para ello se definen algunos operadores que facilitan la manipulación de los constructores \AgdaInductiveConstructor{suc}. La función \AgdaFunction{suc$^{r-1}$} es la inversa del constructor \AgdaInductiveConstructor{suc$^l$} y sirve para quitar un constructor \AgdaInductiveConstructor{suc} del lado derecho de la desigualdad. La función \AgdaFunction{suc$^{-1}$} es la inversa del constructor \AgdaInductiveConstructor{suc} de la desigualdad y quita un constructor de ambos lados de la misma. Por último, \AgdaFunction{$\gtrsim$suc} demuestra que, para cualquier valor \AgdaBound{n} de tipo \AgdaDatatype{$\infty$ Co$\mathbb{N}$}, \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{$\gtrsim$} \AgdaField{$\flat$} \AgdaBound{n}.
\ExecuteMetaData[latex/ConaturalsM.tex]{partial}

La prueba de transitividad es la única que tiene una dificultad un poco mayor ya que se definió en tres partes. \AgdaFunction{trans$\gtrsim$zero} prueba la transitividad para el caso en que el elemento más pequeño es \AgdaInductiveConstructor{zero}. Esta tiene pocos casos y se define co-recursivamente. Luego están \AgdaFunction{trans$\gtrsim$suc} y \AgdaFunction{trans$\gtrsim$} que son mutuamente co-recursivas. La primera prueba el caso particular en el que el elemento más chico es sucesor de algún número y la segunda es la prueba general, la cual utiliza las dos anteriores. Son mutuamente co-recursivas puesto que para probar \AgdaFunction{trans$\gtrsim$suc} se necesita también utilizar \AgdaFunction{trans$\gtrsim$}. 

Por último, se definen las dos operaciones que forman las estructuras monoidales de \AgdaDatatype{Co$\mathbb{N}$} junto con el neutro \AgdaInductiveConstructor{zero}. \begin{itemize}[noitemsep]
\item \AgdaFunction{max} se define como el máximo de dos co-números y es la versión simplificada del operador \AgdaFunction{merge} definido para el tipo \textit{delay}. Esto se puede notar ya que en \AgdaFunction{merge}, en el caso de tener dos valores de la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}), el resultado se construye con un sólo \AgdaInductiveConstructor{later} y ambos términos reducidos dentro de la llamada co-recursiva. Se puede pensar que el resultado de aplicar \AgdaFunction{merge} es el par de los valores de retorno de sus argumentos con una cantidad de constructores \AgdaInductiveConstructor{later} equivalente al máximo de las cantidades que tenía cada argumento. 

\item \AgdaFunction{sum} calcula la suma de dos conúmeros. En este caso, a diferencia de \AgdaFunction{max}, todos los constructores \AgdaInductiveConstructor{suc} persisten. En el caso de que ambos conúmeros sean de la forma (\AgdaInductiveConstructor{suc} \AgdaBound{x}), el resultado consta de dos constructores \AgdaInductiveConstructor{suc} consecutivos y dentro de ellos la llamada co-recursiva con ambos números reducidos. Aunque es un poco más difícil ver el paralelistmo, esta función se corresponde con el operador \AgdaFunction{bind} definido para el tipo \textit{delay}. Si se observa su definición, se puede ver que la función \AgdaBound{f} queda intacta hasta el caso en el que el primer argumento es de tipo (\AgdaInductiveConstructor{now} \AgdaBound{x}), en el cual se aplica al valor \AgdaBound{x}. Si se piensa el comportamiento global de la función, la cantidad de constructores \AgdaInductiveConstructor{later} que tiene el resultado de aplicar \AgdaFunction{bind}, es la suma de la cantidad que posee el primer argumento y la cantidad que posee \AgdaBound{f x}. Todos los \AgdaInductiveConstructor{later} de \AgdaBound{f x} quedan dentro de los del primer argumento.  
\end{itemize}

\ExecuteMetaData[latex/ConaturalsM.tex]{ops}

\subsection{¿Se puede probar la ley de intercambio?}\label{casodelay:conat:ichange}

Contando con las definiciones básicas introducidas en la sección anterior, se analiza la prueba de la ley de intercambio para los números conaturales. En ella se utilizan varios lemas cuyas pruebas se encuentran en el Apéndice \ref{apendice:lemasmus}. Se listan a continuación sólo los tipos de las propiedades que se utilizan. 

\begin{itemize}[noitemsep]
\item \AgdaFunction{$\equiv\Rightarrow\gtrsim$} $:$ \{\AgdaBound{n$_1$ n$_2$} $:$ \AgdaDatatype{Co$\mathbb{N}$}\} $\rightarrow$ \AgdaBound{n$_1$} \AgdaFunction{$\equiv$} \AgdaBound{n$_2$} $\rightarrow$ \AgdaBound{n$_1$} \AgdaFunction{$\gtrsim$} \AgdaBound{n$_2$} \\ prueba que la desigualdad es reflexiva respecto de la igualdad proposicional.

\item \AgdaFunction{sumzero$_2$} $:$ \{\AgdaBound{m} $:$ \AgdaDatatype{Co$\mathbb{N}$}\} $\rightarrow$ \AgdaFunction{sum} \AgdaBound{m} \AgdaInductiveConstructor{zero} \AgdaFunction{$\gtrsim$} \AgdaBound{m} \\ prueba que sumar \AgdaInductiveConstructor{zero} a un conúmero \AgdaBound{m} es mayor o igual a \AgdaBound{m}.

\item \AgdaFunction{$\gtrsim$sum} $:$ \{\AgdaBound{m$_1$ m$_2$ n$_1$ n$_2$} $:$ \AgdaDatatype{Co$\mathbb{N}$}\} $\rightarrow$ \AgdaBound{m$_1$} \AgdaFunction{$\gtrsim$} \AgdaBound{m$_2$} $\rightarrow$ \AgdaBound{n$_1$} \AgdaFunction{$\gtrsim$} \AgdaBound{n$_2$} $\rightarrow$ \AgdaFunction{sum} \AgdaBound{m$_1$ n$_1$} \AgdaFunction{$\gtrsim$} \AgdaFunction{sum} \AgdaBound{m$_2$ n$_2$} \\ prueba que la suma es compatible con la relación de orden.

\item \AgdaFunction{$\gtrsim$max} $:$ \{\AgdaBound{m$_1$ m$_2$ n$_1$ n$_2$} $:$ \AgdaDatatype{Co$\mathbb{N}$}\} $\rightarrow$ \AgdaBound{m$_1$} \AgdaFunction{$\gtrsim$} \AgdaBound{m$_2$} $\rightarrow$ \AgdaBound{n$_1$} \AgdaFunction{$\gtrsim$} \AgdaBound{n$_2$} $\rightarrow$ \AgdaFunction{max} \AgdaBound{m$_1$ n$_1$} \AgdaFunction{$\gtrsim$} \AgdaFunction{max} \AgdaBound{m$_2$ n$_2$} \\ prueba que el operador \AgdaFunction{max} es compatible con la relación de orden.
\end{itemize}

En el siguiente código se puede observar el esqueleto de la prueba de \AgdaFunction{interchange} en el cual muchos casos están resueltos de manera trivial. Algunos de los demás casos se pueden probar mediante el uso de lemas extra pero, para este análisis, se centrará el foco en los últimos dos casos. 

\ExecuteMetaData[latex/ConaturalsM.tex]{interchange}

En el penúltimo caso se puede observar que el problema para reconocer términos iguales cuando se utiliza la estructura \AgdaKeyword{with} persiste aún eliminando los tipos de retorno. Una vez más uno se ve obligado a utilizar la cláusula \AgdaFunction{inspect} para ``obligar'' a Agda a notar que dos términos son iguales por definición. Esto hace, además, que la prueba sea mucho más larga de lo necesario, puesto que hay que incluir muchas veces un conector \AgdaFunction{trans$\gtrsim$} extra que agrega una prueba más sólo para que se unifiquen términos iguales. Aún haciendo todas las pruebas necesarias, surge otro problema: a la hora de realizar la llamada co-recursiva, Agda lanza un error que dice que falló el chequeo de terminación, aún cuando la llamada está suspendida dentro de un operador \AgdaCoinductiveConstructor{$\sharp$} y todos los términos se reducen (salvo \AgdaInductiveConstructor{zero} que es el caso base), por lo que uno pensaría que la prueba sí es productiva. Esto mismo sucede en el último caso, el cual se resuelve simplemente utilizando dos constructores \AgdaInductiveConstructor{suc} y dentro la llamada co-recursiva en la cual todos los términos se reducen. 

Esta falla en el chequeo de terminación se repitió en varios lemas que fueron parte de diferentes intentos realizados para demostrar \AgdaFunction{interchange}. Llamadas que parecen productivas y válidas no pasan el chequeo. Como ejemplo básico de una propiedad que, intuitivamente, debería poder demostrarse sin problemas, se presenta el caso de \AgdaFunction{$\gtrsim$zero} que postula que cualquier conúmero es mayor o igual a \AgdaInductiveConstructor{zero}. Una vez más, la prueba de este lema no pasa el chequeo de terminación.

\ExecuteMetaData[latex/ConaturalsM.tex]{zero}

Dada la dificultad de reconocimiento de términos iguales y el problema con el chequeo de terminación, se decidió después de muchos intentos, idas y vueltas, descartar la notación musical como soporte para coinducción.

\section{Cambio de paradigma: \textit{sized types}}\label{casodelay:sized}

Luego de descartar la notación musical como soporte para la coinducción, los \textit{sized types} fueron la opción elegida. Como se introdujo en la sección \ref{coind:agda:sized}, estos poseen índices que ayudan en el chequeo de terminación, por lo que el objetivo de esta sección es ver si los problemas con tal chequeo encontrados en la notación musical están presentes también en esta notación o no. 

En caso de que no se presenten dificultades con la notación, se intentará demostrar que los números conaturales forman un monoide concurrente con la suma y el máximo, demostrando la ley de intercambio para este conjunto que es una versión simplificada del tipo \textit{delay}. La implementación de números conaturales que se presenta a continuación está basada en el módulo \href{https://www.cse.chalmers.se/~nad/publications/danielsson-definitional-interpreters-looping/Conat.html}{\AgdaModule{Conat}} definido por Danielsson \cite{danielsson:2018}. 

\subsection{Definición de los conaturales utilizando \textit{sized types}}\label{casodelay:sized:def}

En la sección \ref{coind:agda:sized} se definieron los números conaturales utilizando \textit{sized types} de la siguiente manera:
\ExecuteMetaData[latex/CoNaturalsS.tex]{conat}

Esta definición consta de dos partes mutuamente recursivas que trabajan juntas para asegurar la terminación de los programas, tal como se explicó cuando se introdujo esta definición. En general muchas de las definiciones sobre este tipo de dato se darán de la misma manera. 

Antes de pasar a definir las relaciones entre números conaturales, se definen dos operaciones que serán de mucha utilidad más adelante. La primera de ellas es \AgdaFunction{pred}, la cual calcula el predecesor de un conúmero, donde el predecesor de \AgdaInductiveConstructor{zero} es sí mismo y el predecesor de cualquier otro conúmero se calcula quitando un constructor \AgdaInductiveConstructor{suc}.
\ExecuteMetaData[latex/CoNaturalsS.tex]{pred}

La segunda función que se define es una conversión de números naturales a números conaturales. Esta función se define, al igual que el tipo \AgdaDatatype{Conat}, en dos partes mutuamente recursivas.
\ExecuteMetaData[latex/CoNaturalsS.tex]{natconat}

Se define ahora entonces la primera de las relaciones entre conúmeros: la bisemejanza. Esta relación está dada también en dos partes y se define únicamente para números de tipo \AgdaDatatype{Conat $\infty$} que son los conúmeros completamente definidos. La segunda definición, \AgdaFunction{$[\_]\_\sim '\_$}, está dada por un tipo \AgdaKeyword{record} coinductivo que tiene un único campo: \AgdaField{force}. Dados un tamaño \AgdaBound{i} y dos conúmeros \AgdaBound{m} y \AgdaBound{n} de tipo \AgdaDatatype{Conat $\infty$}, este campo da una prueba de que \AgdaBound{m} y \AgdaBound{n} son iguales según la primera definición (\AgdaFunction{$[\_]\_\sim\_$}) para un tamaño \AgdaBound{j} menor a \AgdaBound{i}. 

La primera definición, \AgdaFunction{$[\_]\_\sim\_$}, está dada por un tipo \AgdaKeyword{data} y consta de dos constructores. \AgdaInductiveConstructor{zero} postula que \AgdaInductiveConstructor{zero} es igual a sí mismo. Por otra parte,  \AgdaInductiveConstructor{suc} dice que, dados \AgdaBound{m n} $:$ \AgdaDatatype{Conat $\infty$}, si se tiene que \AgdaField{force} \AgdaBound{m} y \AgdaField{force} \AgdaBound{n} son iguales según la segunda definición para un cierto tamaño \AgdaBound{i}, es decir que son iguales según la definición actual para un tamaño \AgdaBound{j} menor a \AgdaBound{i}, entonces \AgdaInductiveConstructor{suc} \AgdaBound{m} y \AgdaInductiveConstructor{suc} \AgdaBound{n} son iguales en la primera relación para el índice \AgdaBound{i}. 
\ExecuteMetaData[latex/CoNaturalsS.tex]{igualdad}

La bisemejanza es una relación de equivalencia, es decir que es reflexiva, simétrica y transitiva, tal como se muestra en los lemas que siguen. Estas demostraciones se resuelven todas de la misma manera: el caso base se prueba con el costructor \AgdaInductiveConstructor{zero} y el caso coinductivo se prueba con el constructor \AgdaInductiveConstructor{suc} y una llamada co-recursiva dentro.
\ExecuteMetaData[latex/CoNaturalsS.tex]{propseq}

Es el turno ahora de definir la relación de orden, la cual está dada también en dos partes y se define sólo para los conúmeros completamente definidos (\AgdaDatatype{Conat $\infty$}). Al igual que para la bisemejanza, la segunda definición da, para un cierto tamaño \AgdaBound{i} y conúmeros \AgdaBound{m n}, una prueba de que \AgdaBound{m} es menor o igual a \AgdaBound{n} según la primera definición pero para un tamaño \AgdaBound{j} menor a \AgdaBound{i}. 

La primera definición, la cual es la principal, tiene dos constructores. El constructor \AgdaInductiveConstructor{zero} postula que para cualquier conúmero \AgdaBound{n}, \AgdaInductiveConstructor{zero} es menor o igual a \AgdaBound{n} para el tamaño dado \AgdaBound{i}. El constructor \AgdaInductiveConstructor{suc}, dada una prueba de que \AgdaField{force} \AgdaBound{m} es menor o igual a \AgdaField{force} \AgdaBound{n} para un tamaño \AgdaBound{j} menor a \AgdaBound{i}, asegura que \AgdaInductiveConstructor{suc} \AgdaBound{m} es menor o igual a \AgdaInductiveConstructor{suc} \AgdaBound{n} para el tamaño \AgdaBound{i}.
\ExecuteMetaData[latex/CoNaturalsS.tex]{orden}

Esta relación es un orden parcial, es decir que es reflexiva, antisimétrica y transitiva. Se prueban a continuación estos tres lemas. La reflexividad está dada respecto de la igualdad proposicional, mientras que la antisimetría se prueba respecto de la bisemejanza. Las tres pruebas se resuelven sin dificultades. 
\ExecuteMetaData[latex/CoNaturalsS.tex]{propsorden}

Para probar que el orden es un orden parcial respecto de la bisemejanza falta un ingrediente más: la reflexividad respecto de la bisemejanza. Es decir que la relación de bisemejanza implica la relación de orden. Se prueba este lema a continuación:
\ExecuteMetaData[latex/CoNaturalsS.tex]{reflorden}

Luego de dar las definiciones básicas se demuestran tres lemas elementales en relación al orden que serán de utilidad para las pruebas que se llevarán a cabo más adelante. El primero de ellos postula que, para cualquier \AgdaBound{n} $:$ \AgdaDatatype{Conat$'$ $\infty$} y tamaño \AgdaBound{i}, \AgdaField{force} \AgdaBound{n} es menor o igual a \AgdaInductiveConstructor{suc} \AgdaBound{n} para el tamaño \AgdaBound{i}. Para esta prueba es necesario utilizar la función \AgdaFunction{helper} que toma un conúmero \AgdaBound{m} y una prueba de que \hbox{\AgdaBound{m} \AgdaFunction{$\equiv$} \AgdaField{force} \AgdaBound{n}} y hace la demostración valiéndose de esta prueba. Esto se debe a que en esta notación también hay un pequeño conflicto para unificar términos (en este caso con el campo \AgdaField{force}), pero se puede solucionar sin mayores dificultades y no vuelve a repetirse este problema en ninguna de las demostraciones que siguen.
\ExecuteMetaData[latex/CoNaturalsS.tex]{menorsuc}

El segundo lema también tiene que ver con la relación entre \AgdaField{force} y \AgdaInductiveConstructor{suc}. En este caso, para cualesquiera \AgdaBound{m} $:$ \AgdaDatatype{Conat $\infty$}, \AgdaBound{n} $:$ \AgdaDatatype{Conat$'$ $\infty$} e \AgdaBound{i} $:$ \AgdaPrimitiveType{Size}, se prueba que si se tiene una prueba de que \hbox{\AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{m} \AgdaFunction{$\leq'$} \AgdaField{force} \AgdaBound{n}}, entonces \AgdaBound{m} es menor o igual a \AgdaInductiveConstructor{suc} \AgdaBound{n} para el mismo tamaño \AgdaBound{i}. El caso base de esta prueba se da con el constructor \AgdaInductiveConstructor{zero}. En el otro caso se utiliza el constructor \AgdaInductiveConstructor{suc} y dentro la propiedad transitiva entre el lema anterior (que prueba que \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaField{force} \AgdaBound{m} \AgdaFunction{$\leq$} \AgdaInductiveConstructor{suc} \AgdaBound{m}) y (\AgdaField{force} \AgdaBound{p}) (que prueba que \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaInductiveConstructor{suc} \AgdaBound{m} \AgdaFunction{$\leq$} \AgdaField{force} \AgdaBound{n}). 
\ExecuteMetaData[latex/CoNaturalsS.tex]{pasosuc}

Por último, el tercer lema que se prueba indica que el predecesor de un conúmero es menor o igual a dicho conúmero. Esta prueba se resuelve utilizando también el lema \AgdaFunction{$\leq$suc}.
\ExecuteMetaData[latex/CoNaturalsS.tex]{predmenor}

Antes de intentar demostrar la ley de intercambio y dar la instancia de \AgdaRecord{ConcurrentMonoid} para el tipo \AgdaDatatype{Conat $\infty$}, es importante saber si esta representación tiene también problemas con el chequeo de terminación o no. Si bien no se puede asegurar por completo, es deseable corroborar al menos el ejemplo dado para la notación musical. En este caso, la prueba de que todo conúmero es mayor o igual a \AgdaInductiveConstructor{zero} está dada por la definición de la relación de orden. Uno podría pensar entonces que la forma de dar tal definición influye en el desarrollo de las demostraciones a realizar. Para refutar esto, se muestra una definición alternativa de la relación de orden, la cual es análoga a la utilizada en la notación musical. 
\ExecuteMetaData[latex/CoNaturalsS.tex]{ordenalt}

Usando esta relación alternativa, se prueba a continuación que \AgdaInductiveConstructor{zero} es menor o igual a todo conúmero, prueba que se puede hacer sin problemas gracias a los índices que ayudan en el chequeo de terminación. 
\ExecuteMetaData[latex/CoNaturalsS.tex]{zeromenor}

Más aún, se puede probar que ambas relaciones de orden son equivalentes. 
\ExecuteMetaData[latex/CoNaturalsS.tex]{ordeneseq}

Se utiliza entonces la primera por cuestiones de practicidad.

\subsection{Prueba de que los conaturales forman un monoide concurrente}\label{casodelay:sized:concurrent}

Una vez definidos los números conaturales y sus relaciones, y con bastante seguridad de que esta notación no generará tantos conflictos como la primera, se procede a demostrar que los conúmeros forman un monoide concurrente. Para comenzar, se define la operación correspondiente a la suma como sigue:
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{suma}

La suma junto con el valor especial \AgdaInductiveConstructor{zero} forman una estructura monoidal. Es decir que \AgdaInductiveConstructor{zero} es neutro a izquierda y derecha de la suma y que, además, la suma es asociativa. Estas tres propiedades se demuestran sin mayores dificultades.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{propsuma}

Se prueba a continuación la compatibilidad de la suma con la relación de orden, es decir que la suma es monótona respecto de \AgdaFunction{$\leq$}. Para ello se prueba antes un lema que indica que un número siempre es menor o igual a sí mismo sumado con otro. En la prueba de \AgdaFunction{\_max-mono\_} sólo se requiere dicho lema con la suma a uno de los lados, se prueba también su simétrico ya que será utilizado más adelante. Estos dos lemas no podían probarse para la notación musical puesto que fallaba el chequeo de terminación, con \textit{sized types} no se tiene este problema.\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{monosuma}

La compatibilidad de la suma con el orden se prueba por coinducción en el primer argumento: \AgdaBound{m$_1$} \AgdaFunction{$\leq$} \AgdaBound{m$_2$}. En el caso base, cuando esta prueba está dada por el constructor \AgdaInductiveConstructor{zero}, se tiene que \AgdaBound{m$_1$} $=$ \AgdaInductiveConstructor{zero}, por lo que lo se quiere probar es que \AgdaBound{n$_1$} \AgdaFunction{$\leq$} \AgdaBound{m$_2$} \AgdaFunction{+} \AgdaBound{n$_2$}. Se utiliza primero el argumento \AgdaBound{q} para probar que \AgdaBound{n$_1$} \AgdaFunction{$\leq$} \AgdaBound{n$_2$} y luego el lema \AgdaFunction{m$\leq$n+m} para probar que \AgdaBound{n$_2$} \AgdaFunction{$\leq$} \AgdaBound{m$_2$} \AgdaFunction{+} \AgdaBound{n$_2$}, uniendo ambas pruebas con la transitividad de \AgdaFunction{$\leq$}. 

El caso en el que el primer argumento es \AgdaInductiveConstructor{suc} \AgdaBound{p}, se tiene que \AgdaBound{m$_1$} $=$ \AgdaInductiveConstructor{suc} \AgdaBound{m$_1'$}, \AgdaBound{m$_2$} $=$ \AgdaInductiveConstructor{suc} \AgdaBound{m$_2'$} y \hbox{\AgdaBound{p} $:$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaField{force} \AgdaBound{m$_1'$} \AgdaFunction{$\leq'$} \AgdaField{force} \AgdaBound{m$_2'$}}. El objetivo es probar que \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaInductiveConstructor{suc} $\lambda$ \{ $.$\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{m$_1'$} \AgdaFunction{+} \AgdaBound{n$_1$} \} \AgdaFunction{$\leq$} \AgdaInductiveConstructor{suc} $\lambda$ \{ $.$\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{m$_2'$} \AgdaFunction{+} \AgdaBound{n$_2$} \}. Quitando el constructor \AgdaInductiveConstructor{suc} a ambos lados (lo cual se realiza al aplicar en la prueba el constructor de la desigualdad que tiene el mismo nombre) queda por probar que \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaField{force} \AgdaBound{m$_1'$} \AgdaFunction{+} \AgdaBound{n$_1$} \AgdaFunction{$\leq$} \AgdaField{force} \AgdaBound{m$_2'$} \AgdaFunction{+} \AgdaBound{n$_2$}, para algún \AgdaBound{j} menor a \AgdaBound{i}. Esta última prueba es el resultado de aplicar \AgdaFunction{\_+-mono\_} a \AgdaField{force} \AgdaBound{p} y \AgdaBound{q}.

Terminadas las propiedades respectivas a la suma, se pasa a definir el operador \AgdaFunction{max}. Para evitar tener tres casos en la definición como se tenía en la notación musical, se agrupan los últimos dos en uno sólo. El máximo entre (\AgdaInductiveConstructor{suc} \AgdaBound{m}) y \AgdaBound{n} se define como el sucesor del máximo entre (\AgdaField{force} \AgdaBound{m}) y (\AgdaFunction{pred} \AgdaBound{n}). Al aplicar el predecesor al segundo argumento lo que se hace es unificar el caso en que \AgdaBound{n} $=$ \AgdaInductiveConstructor{zero} y el caso en que \AgdaBound{n} $=$ \AgdaInductiveConstructor{suc} \AgdaBound{n$'$}. En el primer caso la función \AgdaFunction{pred} no hace nada y se obtiene el sucesor del máximo entre (\AgdaField{force} \AgdaBound{m}) y \AgdaInductiveConstructor{zero}, al igual que se definió para la notación musical. En el segundo caso aplicar el predecesor quita un constructor \AgdaInductiveConstructor{suc} al segundo argumento, lo cual se condice con el comportamiento que se tenía en la notación musical donde, cuando ambos conúmeros eran sucesores de otros, se dejaba un único constructor \AgdaInductiveConstructor{suc} y se reducían ambos argumentos en la llamada co-recursiva.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{max}

El operador \AgdaFunction{max} junto con el valor especial \AgdaInductiveConstructor{zero} deben formar también una estructura monoidal. Se prueban a continuación ambas identidades de forma muy simple. 
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{idsmax}

Para demostrar la asociatividad del operador \AgdaFunction{max}, se necesitan dos lemas extra:
\begin{itemize}[noitemsep]
\item \AgdaFunction{\_max-cong\_} $:$ $\forall$ \{\AgdaBound{i m$_1$ m$_2$ n$_1$ n$_2$}\} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{m$_1$} \AgdaFunction{$\sim$} \AgdaBound{m$_2$} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{n$_1$} \AgdaFunction{$\sim$} \AgdaBound{n$_2$} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max} \AgdaBound{m$_1$ n$_1$} \AgdaFunction{$\sim$} \AgdaFunction{max} \AgdaBound{m$_2$ n$_2$} que prueba que el operador \AgdaFunction{max} es compatible con la bisemejanza 
\item y \AgdaFunction{pred-max} $:$ $\forall$ \{\AgdaBound{i}\} \AgdaBound{m n} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max} (\AgdaFunction{pred} \AgdaBound{m}) (\AgdaFunction{pred} \AgdaBound{n}) \AgdaFunction{$\sim$} \AgdaFunction{pred} (\AgdaFunction{max} \AgdaBound{m n}) que prueba que el máximo de los predecesores es igual al predecesor del máximo. 
\end{itemize}
Las demostraciones de estos lemas se encuentran en el apéndice \ref{apendice:lemassz} para no extender demasiado esta sección.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{assocmax}
Se prueba \AgdaFunction{max-assoc} por coinducción en el primer argumento. En el caso en que \AgdaBound{n} $=$ \AgdaInductiveConstructor{zero}, el objetivo pasa a ser probar que \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max} \AgdaBound{m o} \AgdaFunction{$\sim$} \AgdaFunction{max} \AgdaBound{m o}, puesto que \AgdaFunction{max} \AgdaInductiveConstructor{zero} \AgdaBound{m} $=$ \AgdaBound{m} y \hbox{\AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaFunction{max} \AgdaBound{m o}) $=$ \AgdaFunction{max} \AgdaBound{m o}}. Luego se resuelve ese caso mediante la reflexividad de la bisemejanza. \\
En el segundo caso el objetivo es ver que: \hbox{\AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max}  (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{n}) \AgdaBound{m}) \AgdaBound{o} \AgdaFunction{$\sim$} \AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{n}) (\AgdaFunction{max} \AgdaBound{m o})}.
O lo que es equivalente:
\begin{center}
\AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max}  (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$  \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred}  \AgdaBound{m}) \}) \AgdaBound{o} \AgdaFunction{$\sim$} 
\\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred}  (\AgdaFunction{max} \AgdaBound{m o})) \}
\end{center}
Aplicando el \AgdaFunction{max} de afuera en el lado izquierdo se obtiene:
\begin{center} 
\AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max}  (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$  \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred}  \AgdaBound{m}) \}) (\AgdaFunction{pred} \AgdaBound{o}) \} \AgdaFunction{$\sim$}
\\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred} (\AgdaFunction{max} \AgdaBound{m o})) \}
\end{center}
Al aplicar en la prueba \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ ... \} se quita esta construcción a cada lado de la igualdad. El nuevo objetivo es probar que:
\begin{center} 
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max}  (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred}  \AgdaBound{m}))  (\AgdaFunction{pred} \AgdaBound{o}) \AgdaFunction{$\sim$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred} (\AgdaFunction{max} \AgdaBound{m o}))
\end{center}
Se resuelve esta prueba utilizando \AgdaFunction{transitive-$\sim$} entre (\AgdaFunction{max-assoc} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred} \AgdaBound{m}) (\AgdaFunction{pred} \AgdaBound{o})) que prueba: 
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max}  (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{pred}  \AgdaBound{m}))  (\AgdaFunction{pred} \AgdaBound{o}) \AgdaFunction{$\sim$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{n}) (\AgdaFunction{max} (\AgdaFunction{pred} \AgdaBound{m}) (\AgdaFunction{pred} \AgdaBound{o})) y \AgdaFunction{\_max-cong\_} aplicado a \AgdaFunction{reflexive-$\sim$} (\AgdaField{force} \AgdaBound{n}) que deja el primer argumento como está y \AgdaFunction{pred-max} que cambia (\AgdaFunction{max} (\AgdaFunction{pred} \AgdaBound{m}) (\AgdaFunction{pred} \AgdaBound{o})) por (\AgdaFunction{pred} (\AgdaFunction{max} \AgdaBound{m o})).

Se presenta a continuación la función \AgdaFunction{\_max-mono\_}, la cual, análogamente a \AgdaFunction{\_+-mono\_}, representa la compatibilidad del operador \AgdaFunction{max} con la relación de orden. También de manera similar a lo ocurrido con \AgdaFunction{\_+-mono\_}, para demostrar este lema se requiere de un lema extra, \AgdaFunction{$^r\leq$max}, similar a \AgdaFunction{m$\leq$n+m}, que postula que un conúmero siempre es menor o igual al máximo entre él mismo y otro. Se prueba también su lema simétrico, \AgdaFunction{$^l\leq$max}, el cual es análogo a \AgdaFunction{m$\leq$m+m} ya que también será necesario en la prueba de la ley de intercambio. Ambos lemas se demuestran sin dificultade de manera co-recursiva.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{monomax}

La demostración de \AgdaFunction{\_max-mono\_} es análoga a la de \AgdaFunction{\_+-mono\_}, con la única diferencia de que se separa en casos el segundo argumento cuando el primero tiene la forma (\AgdaInductiveConstructor{suc} \AgdaBound{n}). En ambos casos la prueba se resuelve con un constructor \AgdaInductiveConstructor{suc} y dentro una llamada co-recursiva, en el primer caso el segundo argumento de dicha llamada es la prueba \AgdaInductiveConstructor{zero} y en el otro es la prueba del segundo argumento de la llamada actual quitándole un constructor \AgdaInductiveConstructor{suc}.

Queda una propiedad más por probar para el operador \AgdaFunction{max}: la conmutatividad. Dicha propiedad es requerida para que los conaturales formen  un monoide concurrente. En el caso en que ambos conúmeros son \AgdaInductiveConstructor{zero}, la prueba es trivial. Cuando uno de los dos es \AgdaInductiveConstructor{zero} y el otro tiene la forma (\AgdaInductiveConstructor{suc} \AgdaBound{x}), el resultado de \AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaInductiveConstructor{suc} \AgdaBound{x}) es, por definición, (\AgdaInductiveConstructor{suc} \AgdaBound{x}) y se usa el lema \AgdaFunction{max-right-identity} para demostrar que \AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{x}) \AgdaInductiveConstructor{zero} tiene el mismo resultado. Cuando ambos argumentos están formados por un constructor \AgdaInductiveConstructor{suc}, se resuelve co-recursivamente.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{commmax}

Queda por demostrar únicamente la ley de intercambio. Esta está representada por la función \AgdaFunction{interchange}, cuya definición se explicará caso por caso. Para poder realizar esta prueba se requieren algunos lemas extra además de los que fueron demostrados o mencionados anteriormente. Se lista a continuación el tipo de cada uno de estos lemas para que la prueba pueda comprenderse, las demostraciones de los mismos se encuentran en el apéndice \ref{apendice:lemassz} para no extender demasiado esta sección.
\begin{itemize}[noitemsep]
\item \AgdaFunction{+-comm} $:$ $\forall$ \AgdaBound{m} \{\AgdaBound{n i}\} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{m} \AgdaFunction{+} \AgdaBound{n} \AgdaFunction{$\sim$} \AgdaBound{n} \AgdaFunction{+} \AgdaBound{m} prueba la conmutatividad de la suma.

\item \AgdaFunction{\_+-cong\_} $:$ $\forall$ \{\AgdaBound{i m$_1$ m$_2$ n$_1$ n$_2$}\} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{m$_1$} \AgdaFunction{$\sim$} \AgdaBound{m$_2$} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{n$_1$} \AgdaFunction{$\sim$} \AgdaBound{n$_2$} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaBound{m$_1$} \AgdaFunction{+} \AgdaBound{n$_1$} \\ \AgdaFunction{$\sim$} \AgdaBound{m$_2$} \AgdaFunction{+} \AgdaBound{n$_2$}, análogamente a \AgdaFunction{\_max-cong\_}, prueba que la suma es compatible con la bisemejanza.

\item \AgdaFunction{max$\leq$+} $:$ $\forall$ \{\AgdaBound{i m n}\} $\rightarrow$ \AgdaFunction{[} \AgdaBound{i} \AgdaFunction{]} \AgdaFunction{max} \AgdaBound{m n} \AgdaFunction{$\leq$} \AgdaBound{m} \AgdaFunction{+} \AgdaBound{n} prueba que el máximo de dos conúmeros es menor o igual a su suma.
\end{itemize}

\begin{AgdaAlign}
El tipo de la función \AgdaFunction{interchange} postula que, dados cuatro conúmeros \AgdaBound{a}, \AgdaBound{b}, \AgdaBound{c} y \AgdaBound{d}, el máximo de las sumas (\AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) y (\AgdaBound{c} \AgdaFunction{+} \AgdaBound{d}) es menor o igual a la suma de los máximos (\AgdaFunction{max} \AgdaBound{a} \AgdaBound{c}) y \hbox{(\AgdaFunction{max} \AgdaBound{b} \AgdaBound{d})}. Intuitivamente tiene sentido ya que en el primer caso se toma la suma que sea más grande pero, en el segundo, se toman los máximos sumandos para cada lado de la suma, permitiendo combinar el primer sumando más grande con el mayor segundo sumando aunque estos estén en distintas sumas en el lado izquierdo de la desigualdad. Este razonamiento fue el que llevó a elegir la orientación de la desigualdad en la formalización tanto de los monoides concurrentes como las mónadas concurrentes. 
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{itipo}

\begin{itemize}
\item El primer caso a analizar es aquel en el que tanto \AgdaBound{a} como 
\AgdaBound{c} son \AgdaInductiveConstructor{zero}. \AgdaBound{b} y \AgdaBound{d} pueden ser cualquier conúmero.
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso1}

Por definición se tiene que \AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaBound{b} $=$ \AgdaBound{b} y \AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaBound{d} $=$ \AgdaBound{d}. Luego el lado izquierdo se reduce a \AgdaFunction{max} \AgdaBound{b} \AgdaBound{d}. Por otro lado, \AgdaFunction{max} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{zero} $=$ \AgdaInductiveConstructor{zero} y, por lo tanto, \AgdaFunction{max} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaFunction{max} \AgdaBound{b d} $=$ \AgdaFunction{max} \AgdaBound{b d}. Como el resultado a ambos lados es el mismo, el primer caso se prueba de forma trivial utilizando la reflexividad de la bisemejanza.

\begin{itemize}
\item El segundo caso es el primero de varios en los que se considera que \AgdaBound{a} $=$ \AgdaInductiveConstructor{zero} y el tercer argumento es (\AgdaInductiveConstructor{suc} \AgdaBound{c}). En este en particular se considerará que \AgdaBound{b} también es \AgdaInductiveConstructor{zero} mientras que el último es un \AgdaBound{d} cualquiera. 
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso2}

En el lado izquierdo la suma de \AgdaBound{a} y \AgdaBound{b} da como resultado \AgdaInductiveConstructor{zero} y entonces se reduce a \AgdaFunction{max} \AgdaInductiveConstructor{zero} ((\AgdaInductiveConstructor{suc} \AgdaBound{c}) \AgdaFunction{+} \AgdaBound{d}) $=$ (\AgdaInductiveConstructor{suc} \AgdaBound{c}) \AgdaFunction{+} \AgdaBound{d}. En el lado derecho se tiene que \hbox{\AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaInductiveConstructor{suc} \AgdaBound{c}) $=$ (\AgdaInductiveConstructor{suc} \AgdaBound{c})} y \AgdaFunction{max} \AgdaInductiveConstructor{zero} \AgdaBound{d} $=$ \AgdaBound{d}, por lo que también reduce a (\AgdaInductiveConstructor{suc} \AgdaBound{c}) \AgdaFunction{+} \AgdaBound{d}. Por lo tanto, este caso también es trivial.

\begin{itemize}
\item El tercer caso que se considera sigue con \AgdaBound{a} $=$ \AgdaInductiveConstructor{zero} y el tercer argumento como sucesor de un conúmero: \AgdaInductiveConstructor{suc} \AgdaBound{c}. Ahora el segundo ya no es \AgdaInductiveConstructor{zero} sino que es también un sucesor, \AgdaInductiveConstructor{suc} \AgdaBound{b}, y se toma \AgdaBound{d} $=$  \AgdaInductiveConstructor{zero}. 
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso3}

El lado izquierdo de la desigualdad a demostrar en este caso puede reducirse siguiendo el siguiente análisis: 

\AgdaFunction{max} (\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) \\ 
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero} \}) \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero} \})) \}\\ 
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) \}

En el lado derecho, por otro lado, se puede realizar la siguiente reducción:
\begin{flushright}
(\AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaInductiveConstructor{suc} \AgdaBound{c})) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) \AgdaInductiveConstructor{zero}) \\
(\AgdaInductiveConstructor{suc} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \}) $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \}) \} $=$
\end{flushright}

Quitando de ambos la construcción \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ ... \} de más afuera al ponerla en la prueba, el objetivo a demostrar es: 
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) \AgdaFunction{$\leq$} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \})
\end{center}
donde \AgdaBound{j} es menor a \AgdaBound{i}.

El primer paso de la prueba se realiza a partir del término (\AgdaFunction{reflexive-$\sim$} (\AgdaField{force} \AgdaBound{b}) \AgdaFunction{max-cong} \AgdaFunction{+-right-identity} (\AgdaField{force} \AgdaBound{c})) que prueba que 
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) \AgdaFunction{$\sim$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c}) 
\end{center}
Luego el lema \AgdaFunction{$\sim\rightarrow\leq$} lo convierte en desigualdad. 

El siguiente paso utiliza el lema \AgdaFunction{max$\leq$+} aplicado a (\AgdaField{force} \AgdaBound{b}) y (\AgdaField{force} \AgdaBound{c}), demostrando que:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{$\leq$}  (\AgdaField{force} \AgdaBound{b}) \AgdaFunction{+} (\AgdaField{force} \AgdaBound{c})
\end{center}

Utilizando la conmutatividad de la suma, que puede convertirse en desigualdad al aplicar el lema \AgdaFunction{$\sim\rightarrow\leq$}, se prueba que:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]}  (\AgdaField{force} \AgdaBound{b}) \AgdaFunction{+} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{$\leq$}  (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaField{force} \AgdaBound{b})
\end{center}

En el último paso se utiliza el lema \AgdaFunction{+-mono} para resolver la prueba sumando a sumando. De un lado se pasa como argumento la prueba \hbox{(\AgdaFunction{reflexive-$\leq$} (\AgdaField{force} \AgdaBound{c}))} para que el lado izquierdo de la suma quede igual. El segundo lado es el más interesante. El objetivo es ver que: 
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]}  (\AgdaField{force} \AgdaBound{b}) \AgdaFunction{$\leq$} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \})
\end{center}

Primero se utiliza el lema \AgdaFunction{$\leq$suc} para probar que \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaField{force} \AgdaBound{b} \AgdaFunction{$\leq$} \AgdaInductiveConstructor{suc} \AgdaBound{b}, el nuevo objetivo a demostrar es entonces:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]}  (\AgdaInductiveConstructor{suc} \AgdaBound{b}) \AgdaFunction{$\leq$} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \})
\end{center}

Al quitar el constructor \AgdaInductiveConstructor{suc} de ambos lados, queda por probar simplemente que, para un \AgdaBound{k} menor a \AgdaBound{j}, \hbox{\AgdaFunction{[} \AgdaBound{k} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{b}) \AgdaFunction{$\leq$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) \AgdaInductiveConstructor{zero}}. Esto se obtiene utilizando el lema \AgdaFunction{max-right-identity} (dado vuelta con \AgdaFunction{symmetric-$\sim$} y convertido en desigualdad por \AgdaFunction{$\sim\rightarrow\leq$}).

\begin{itemize}
\item En el cuarto caso se conserva que \AgdaBound{a} $=$ \AgdaInductiveConstructor{zero} y el segundo y el tercer argumento son sucesores de un conúmero: (\AgdaInductiveConstructor{suc} \AgdaBound{b}) y  (\AgdaInductiveConstructor{suc} \AgdaBound{c}). El último, que antes era \AgdaInductiveConstructor{zero} ahora es también un sucesor: (\AgdaInductiveConstructor{suc} \AgdaBound{d}).
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso4}

El lado izquierdo de la desigualdad se puede reducir en este caso de la siguiente manera: 

\AgdaFunction{max} (\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \\
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d} \}) \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d} \})) \} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \} 

El lado derecho puede reducirse, por su parte, siguiendo los siguientes pasos:
\begin{flushright}
(\AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaInductiveConstructor{suc} \AgdaBound{c})) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \\
(\AgdaInductiveConstructor{suc} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \}) $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}) \} $=$
\end{flushright}

Quitando de ambos lados la estructura \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ ... \}, el objetivo a demostrar queda, para un \AgdaBound{j} menor a \AgdaBound{i}, como sigue:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \})
\end{center}

Aplicando la llamada co-recursiva (\AgdaFunction{interchange} \AgdaInductiveConstructor{zero} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})), se obtiene que:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d}))
\end{center}

El nuevo objetivo a demostrar es entonces:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \AgdaFunction{$\leq$} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \})
\end{center}

Como se puede observar, en ambos lados hay sumas y, además, los primeros sumandos de las mismas son iguales. Se aplica por lo tanto \AgdaFunction{reflexive-$\leq$} (\AgdaField{force} \AgdaBound{c}) \AgdaFunction{+-mono}, de manera que lo que queda por probar es la desigualdad entre los segundos sumandos de cada uno de los lados. El objetivo es ahora:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d}) \AgdaFunction{$\leq$} \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}
\end{center}

El primer paso para demostrarlo es aplicar (\AgdaFunction{$\sim\rightarrow\leq$} (\AgdaFunction{max-comm} (\AgdaField{force} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d}))), lo cual cambia el orden de los argumentos del operador \AgdaFunction{max} de manera que pueda evaluarse tal operación, obteniéndose \AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{d}) (\AgdaField{force} \AgdaBound{b}). Esta expresión se reduce, por definición, a (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{d}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})) \}) Luego de aplicar esto, el objetivo a demostrar es:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{d}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})) \} \AgdaFunction{$\leq$} \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}
\end{center}

Se quita a ambos lados el constructor \AgdaInductiveConstructor{suc} y el nuevo objetivo es, para un \AgdaBound{k} menor a \AgdaBound{j}:
\begin{center}
\AgdaFunction{[} \AgdaBound{k} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{d}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})) \AgdaFunction{$\leq$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d})
\end{center}

Ambas expresiones son similares, sólo cambia el orden de los argumentos y que (\AgdaField{force} \AgdaBound{b}) a la izquierda tiene aplicada la función predecesor. Para probar esta desigualdad se realizan dos pasos. El primero es aplicar (\AgdaFunction{$\sim\rightarrow\leq$} (\AgdaFunction{max-comm} (\AgdaField{force} \AgdaBound{d}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})))) de manera que el orden de los argumentos vuelva a como era inicialmente, obteniéndose \AgdaFunction{max} (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})) (\AgdaField{force} \AgdaBound{d}). Luego se aplica el lema \AgdaFunction{max-mono} con \AgdaFunction{pred$\leq$} a la izquierda que prueba que (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{b})) es menor o igual a (\AgdaField{force} \AgdaBound{b}) y a la derecha \AgdaFunction{reflexive-$\leq$} (\AgdaField{force} \AgdaBound{d}) que prueba que (\AgdaField{force} \AgdaBound{d}) es menor o igual a sí mismo.

\begin{itemize}
\item En el quinto caso se comienza a considerar que el primer argumento es un sucesor, (\AgdaInductiveConstructor{suc} \AgdaBound{a}), puesto que todos los casos en los cuales el primer argumento es \AgdaInductiveConstructor{zero} ya fueron analizados. En este y los dos casos siguientes se toma \AgdaBound{c} $=$ \AgdaInductiveConstructor{zero}. En este en particular el segundo argumento es un conúmero cualquiera \AgdaBound{b} y el último es \AgdaInductiveConstructor{zero}.
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso5}

Al analizar el lado izquierdo de la desigualdad en este caso, se obtiene lo siguiente:

\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) (\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) \\
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b} \}) \AgdaInductiveConstructor{zero} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b} \}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \}

Por otro lado, el lado derecho puede reducirse de la siguiente manera:

\begin{flushright}
(\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero}) \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero}) $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero} \}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero}) \} $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero}) \} $=$
\end{flushright}

Como en ambos lados hay un constructor \AgdaInductiveConstructor{suc}, este puede quitarse en cada lado. Luego de hacerlo el objetivo a demostrar es, para un \AgdaBound{j} menor a \AgdaBound{i}:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}	) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero})
\end{center}

Ambos lados de esta desigualdad son, en realidad, iguales. Se demuestra entonces la igualdad \hbox{\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) \AgdaInductiveConstructor{zero} \AgdaFunction{$\sim$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero})} y luego se utiliza el lema \AgdaFunction{$\sim\rightarrow\leq$} para obtener la desigualdad. El primer paso para demostrar la igualdad es reducir la expresión \AgdaFunction{max} en el lado izquierdo de la misma. Para esto se utiliza el lema \AgdaFunction{max-right-identity} aplicado a (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) que postula que el resultado de calcular el máximo de un conúmero y \AgdaInductiveConstructor{zero} es igual al primer conúmero. Luego de aplicar este lema se obtiene la siguiente proposición 	a demostrar:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{a}) \AgdaFunction{+} \AgdaBound{b} \AgdaFunction{$\sim$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}	) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b} \AgdaInductiveConstructor{zero})
\end{center}

Es preciso notar que a ambos lados hay una suma y que los sumandos son iguales salvo que a la derecha están dentro de una aplicación de \AgdaFunction{max} con \AgdaInductiveConstructor{zero}. Se debe utilizar entonces nuevamente el lema \AgdaFunction{max-right-identity} a ambos lados de la suma. Las dos aplicaciones de este lema, una a (\AgdaField{force} \AgdaBound{a}) y la otra a \AgdaBound{b}, se unen con el lema \AgdaFunction{+-cong} que establece que las sumas de sumandos iguales dan resultados iguales.

\begin{itemize}
\item En el sexto caso se sigue tomando el primer argumento como sucesor, (\AgdaInductiveConstructor{suc} \AgdaBound{a}), y el tercero como \AgdaInductiveConstructor{zero}. El último argumento ya no es \AgdaInductiveConstructor{zero} sino que pasa a ser sucesor de un conúmero: (\AgdaInductiveConstructor{suc} \AgdaBound{d}). Por último, se toma \AgdaBound{b} $=$ \AgdaInductiveConstructor{zero}.
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso6}

El análisis del lado izquierdo de la desigualdad en este caso queda como sigue:

\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) (\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \\
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero} \}) (\AgdaInductiveConstructor{suc} \AgdaBound{d}) \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero} \}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) (\AgdaField{force} \AgdaBound{d}) \} 

El lado derecho, por su parte, queda de la siguiente manera:

\begin{flushright}
(\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaInductiveConstructor{zero} (\AgdaInductiveConstructor{suc} \AgdaBound{d}))\\ 
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d}) $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d}) \}  $=$  \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a})  \AgdaInductiveConstructor{zero})  \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d}) \} $=$
\end{flushright} 

Al igual que en los casos anteriores se quita el constructor \AgdaInductiveConstructor{suc} a cada lado y el objetivo a demostrar pasa ser, para un \AgdaBound{j} menor a \AgdaBound{i}:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a})  \AgdaInductiveConstructor{zero})  \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d})
\end{center}

Primero se resuelve la suma (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{zero}) utilizando el lema \AgdaFunction{+-right-identity} que establece la identidad derecha del \AgdaInductiveConstructor{zero} respecto de la suma. Como el término a resolver está dentro de una aplicación de \AgdaFunction{max}, se utiliza el lema \AgdaFunction{max-cong} con (\AgdaFunction{+-right-identity} (\AgdaField{force} \AgdaBound{a})) de un lado para que se resuelva la suma en cuestión y (\AgdaFunction{reflexive-$\sim$} (\AgdaField{force} \AgdaBound{d})) del otro para que este permanezca igual. Como \AgdaFunction{max-cong} prueba una igualdad, se utiliza luego el lema \AgdaFunction{$\sim\rightarrow\leq$} para obtener la desigualdad. Después de esta aplicación el nuevo objetivo a demostrar es el siguiente:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a})  \AgdaInductiveConstructor{zero})  \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d})
\end{center}

De un lado de la desigualdad hay una operación \AgdaFunction{max} y, del otro, una suma. Como es sabido que el máximo de dos conúmeros es menor o igual a su suma, se utiliza el lema \AgdaFunction{max$\leq$+} para convertir el lado izquierdo en una suma, de manera que pueda trabajarse luego sumando a sumando. Luego de aplicar este lema queda por demostrar que:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{a}) \AgdaFunction{+} (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a})  \AgdaInductiveConstructor{zero})  \AgdaFunction{+} (\AgdaInductiveConstructor{suc} \AgdaBound{d})
\end{center}

Esta última demostración se realiza, como se adelantó previamente, sumando a sumando, valiéndose para ello del lema \AgdaFunction{+-mono} que postula la compatibilidad de la suma con la relación de orden. Para probar en el lado izquierdo que \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{a}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a})  \AgdaInductiveConstructor{zero}), se utiliza el lema \AgdaFunction{$^l\leq$max} aplicado a (\AgdaField{force} \AgdaBound{a}) y \AgdaInductiveConstructor{zero} que prueba que un conúmero siempre es menor o igual al máximo de sí mismo con otro. En el lado derecho, por otra parte, se debe probar lo siguiente: \AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaInductiveConstructor{suc} \AgdaBound{d}). Esto se resuelve mediante la utilización del lema \AgdaFunction{$\leq$suc} que prueba que todo conúmero es menor o igual al su sucesor.


\begin{itemize}
\item En el penúltimo caso se conserva que el primer y el último argumento son sucesores, \hbox{(\AgdaInductiveConstructor{suc} \AgdaBound{a})} y (\AgdaInductiveConstructor{suc} \AgdaBound{d}), y que el tercer argumento es \AgdaInductiveConstructor{zero}. Lo que cambia es que el segundo argumento ya no es \AgdaInductiveConstructor{zero} sino que es (\AgdaInductiveConstructor{suc} \AgdaBound{b}).
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso7}

Se analiza el lado izquierdo de la desigualdad de la siguiente manera:

\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{d}) \\
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b} \}) (\AgdaInductiveConstructor{suc} \AgdaBound{d}) \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b} \}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}

Luego se analiza el lado derecho como se muestra a continuación:

\begin{flushright}
(\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaFunction{pred} \AgdaInductiveConstructor{zero}) \}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})) $=$ \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero} \}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{d})) $=$ \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero} \}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} \AgdaBound{d})) \}) $=$ \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero} \}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}) $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \}) \} $=$ 
\end{flushright}

Si se quita el constructor \AgdaInductiveConstructor{suc} de ambos términos se obtiene que, para un \AgdaBound{j} menor a \AgdaBound{i}, el objetivo a demostrar es el siguiente:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} \\ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \})
\end{center}

Se aplica la llamada co-recursiva (\AgdaFunction{interchange} (\AgdaField{force} \AgdaBound{a}) (\AgdaInductiveConstructor{suc} \AgdaBound{b}) \AgdaInductiveConstructor{zero} (\AgdaField{force} \AgdaBound{d})) como primer paso para realizar esta prueba. Esta llamada prueba lo siguiente: 
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}))
\end{center}

El lado derecho de la desigualdad se reescribe, por definición de la operación \AgdaFunction{max}, de la siguiente manera:  (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{d})) \}). Por lo tanto, después de aplicar la llamada co-recursiva, el nuevo objetivo a demostrar es:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{d})) \}) \AgdaFunction{$\leq$} \\ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) \AgdaFunction{+} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \})
\end{center}

Es fácil observar que a ambos lados se cuenta ahora con una suma, donde los primeros sumandos son iguales y los segundos sumandos son bastante similares. Se resuelve entonces esta nueva desigualdad sumando a sumando utilizando el lema \AgdaFunction{+-mono}, pasándole como primer argumento (\AgdaFunction{reflexive-$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero})) que prueba que (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) \AgdaInductiveConstructor{zero}) es menor o igual a sí mismo. Como segundo argumento se deberá dar un término que demuestre que: 
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{d})) \}) \AgdaFunction{$\leq$} \\ (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d}) \})
\end{center}

Lo primero que hay que hacer para demostrarlo es quitar a ambos lados el constructor \AgdaInductiveConstructor{suc}. Luego de hacerlo, lo que queda por demostrar es, para un \AgdaBound{k} menor a \AgdaBound{j}:
\begin{center}
\AgdaFunction{[} \AgdaBound{k} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{d})) \AgdaFunction{$\leq$} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{d})
\end{center} 

En este caso se tiene a ambos lados una operación \AgdaFunction{max}, donde los primeros argumentos son iguales entre sí y los segundos sólo varían en una aplicación de la función predecesor. Luego se prueba esta desigualdad mediante el lema \AgdaFunction{max-mono}. Como primer argumento a este lema se pasa el término (\AgdaFunction{reflexive-$\leq$} (\AgdaField{force} \AgdaBound{b})) que prueba que (\AgdaField{force} \AgdaBound{b}) es menor o igual a sí mismo. Como segundo argumento se utiliza el lema \AgdaFunction{pred$\leq$} que prueba que el predecesor de un conúmero es menor o igual a dicho conúmero para probar que \AgdaFunction{[} \AgdaBound{k} \AgdaFunction{]} (\AgdaFunction{pred} (\AgdaField{force} \AgdaBound{d})) \AgdaFunction{$\leq$} (\AgdaField{force} \AgdaBound{d}).

\begin{itemize}
\item Habiendo analizado todos los casos en los cuales el primer argumento es (\AgdaInductiveConstructor{suc} \AgdaBound{a}) y el tercero es \AgdaInductiveConstructor{zero}, el octavo y último caso considera que el primer y el tercer argumento son sucesores, (\AgdaInductiveConstructor{suc} \AgdaBound{a}) y (\AgdaInductiveConstructor{suc} \AgdaBound{c}), y los otros dos son conúmeros \AgdaBound{b} y \AgdaBound{d} cualesquiera.
\end{itemize}
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{icaso8}

Al analizar el lado izquierdo de la desigualdad, se obtiene lo siguiente:

\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) (\AgdaInductiveConstructor{suc} \AgdaBound{c} \AgdaFunction{+} \AgdaBound{d})\\
$=$ \AgdaFunction{max} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b} \}) (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaBound{d} \})\\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b} \}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaBound{d} \})) \} \\
$=$ \AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaBound{d}) \} 

Cuando se analiza el lado derecho, por otro lado, se obtiene:

\begin{flushright}
(\AgdaFunction{max} (\AgdaInductiveConstructor{suc} \AgdaBound{a}) (\AgdaInductiveConstructor{suc} \AgdaBound{c})) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b d}) \\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaFunction{pred} (\AgdaInductiveConstructor{suc} \AgdaBound{c})) \}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b d}) $=$\\
(\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaField{force} \AgdaBound{c}) \}) \AgdaFunction{+} (\AgdaFunction{max} \AgdaBound{b d}) $=$\\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaField{force} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaField{force} \AgdaBound{c}) \}) (\AgdaFunction{max} \AgdaBound{b d}) \} $=$ \\
\AgdaInductiveConstructor{suc} $\lambda$ \{ .\AgdaField{force} $\rightarrow$ (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaField{force} \AgdaBound{c})) (\AgdaFunction{max} \AgdaBound{b d}) \} $=$ \\
\end{flushright}

Quitando de ambos términos el constructor \AgdaInductiveConstructor{suc}, se obtiene que el objetivo a demostrar es, para un \AgdaBound{j} menor a \AgdaBound{i}:
\begin{center}
\AgdaFunction{[} \AgdaBound{j} \AgdaFunction{]} \AgdaFunction{max} (\AgdaField{force} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}) (\AgdaField{force} \AgdaBound{c} \AgdaFunction{+} \AgdaBound{d}) \AgdaFunction{$\leq$} (\AgdaFunction{max} (\AgdaField{force} \AgdaBound{a}) (\AgdaField{force} \AgdaBound{c})) (\AgdaFunction{max} \AgdaBound{b d})
\end{center}

Esta desigualdad es, exactamente, el resultado que se obtiene al realizar la siguiente llamada co-recursiva: \hbox{\AgdaFunction{interchange} (\AgdaField{force} \AgdaBound{a}) \AgdaBound{b} (\AgdaField{force} \AgdaBound{c}) \AgdaBound{d}}. 

De esta manera queda demostrada la ley de intercambio para los números conaturales. 
\end{AgdaAlign}

Para poder crear la instancia de \AgdaRecord{ConcurrentMonoid} para \AgdaDatatype{Conat $\infty$}, faltan sólo dos ingredientes. Aunque ya se demostraron las propiedades necesarias para ver que la relación de bisemejanza es una relación de equivalencia y que el orden es un orden parcial respecto de la misma, no se dieron las pruebas completas que agrupan estas propiedades. A continuación se muestran entonces las definiciones de los lemas \AgdaFunction{eq-$\sim$} y \AgdaFunction{partial-$\leq$} que prueban que la relación \AgdaFunction{[ $\infty$ ]\_$\sim$\_} es una relación de equivalencia y que la misma relación junto con \AgdaFunction{[ $\infty$ ]\_$\leq$\_} forman un orden parcial, respectivamente.
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{eqpartial}

Finalmente, se puede construir la instancia de \AgdaRecord{ConcurrentMonoid} para el tipo \AgdaDatatype{Conat $\infty$}, demostrando que los números conaturales forman un monoide concurrente. 
\ExecuteMetaData[latex/Instances/ConcurrentMonoid.tex]{instance}

\subsection{Una mónada concurrente alternativa a \textit{delay}}

Como se mencionó anteriormente, se puede pensar a los conaturales como una versión simplificada del tipo \textit{delay} en donde no hay valores de retorno (o bien el tipo de retorno es un tipo con un único habitante y el valor de retorno es siempre el mismo). Una forma de generar una alternativa similar a la mónada \textit{delay} es, por lo tanto, agregar a los conaturales un valor de retorno mediante la utilización del producto cartesiano. Un par (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{a}) es similar a un habitante del tipo \textit{delay} que tiene \AgdaBound{n} constructores \AgdaInductiveConstructor{later} y retorna el valor \AgdaBound{a}. La principal diferencia entre el tipo \AgdaBound{A} \AgdaDatatype{$\bot$} y el tipo \AgdaDatatype{Conat $\infty$ $\times$} \AgdaBound{A} es que, mientras en el primero existe un único término infinito que jamás retorna ningún valor (\AgdaFunction{never}), en el segundo todos los términos tienen un valor de retorno. En consecuencia, existen muchos habitantes de \AgdaDatatype{Conat $\infty$ $\times$} \AgdaBound{A} que nunca terminan: para cada valor \AgdaBound{a} $:$ \AgdaBound{A}, existe (\AgdaFunction{inf} \AgdaInductiveConstructor{,} \AgdaBound{a}). Esta diferencia hace que no sean equivalentes y no puedan utilizarse para los mismos fines, pero de igual manera son bastante similares y en algunos casos puede ser de utilidad. 

El lema \ref{concmonoid->concmonad} postula que si $(A,\sqsubseteq,*,\mathtt{nothing},;,\mathtt{skip})$ con $\mathtt{nothing} = \mathtt{skip}$ es un monoide concurrente, luego el funtor $\mathit{T}_A \ X = A \times X$ constituye una mónada concurrente. El objetivo de esta sección es demostrar este lema y luego concluir que la mónada \textit{writer} para conaturales, \AgdaDatatype{Conat $\infty$ $\times$} \AgdaBound{A}, es una mónada concurrente. 

\begin{AgdaAlign}
Lo primero que es necesario definir para poder realizar la demostración del lema es el funtor $\mathit{T}_A$. La función \AgdaFunction{F} que toma dos conjuntos y devuelve su producto cartesiano representa dicho funtor.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{funtor}

Las definiciones de cada uno de los campos de \AgdaRecord{ConcurrentMonad} se realizarán dentro de un módulo anónimo que tiene como parámetros implícitos un conjunto \AgdaBound{S} y una prueba \AgdaBound{cmonoid} de que tal conjunto es un monoide concurrente. El objetivo de la utilización de este módulo es fijar el conjunto \AgdaBound{S} y abrir la prueba de que es un monoide concurrente para poder utilizar sus campos en las definiciones a realizar. Se define el módulo como se muestra a continuación y se abre \AgdaModule{ConcurrentMonoid} \{\AgdaBound{S}\}\AgdaBound{cmonoid} renombrando cada campo para que no se generen conflictos de nombre. De igual manera se abren las pruebas de equivalencia, orden parcial y preorden para poder acceder fácilmente a sus propiedades internas. 
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{module}

Se define primero la relación de igualdad entre habitantes de \AgdaFunction{F} \AgdaBound{S A} para un \AgdaBound{A} arbitrario. Para los habitantes de \AgdaBound{A} se utilizará la igualdad proposicional, cuyas propiedades \AgdaInductiveConstructor{refl}, \AgdaFunction{sym} y \AgdaFunction{trans} fueron renombradas con una letra \texttt{p} delante para hacer referencia a que corresponden a la igualdad proposicional. Para que dos habitantes de  \AgdaFunction{F} \AgdaBound{S A} sean iguales según la relación \AgdaFunction{\_F$\approx$\_}, las primeras componentes de cada par deben ser iguales según la igualdad extraída de \AgdaBound{cmonoid} y las segundas deben iguales según la igualdad proposicional. Utilizando las propiedades de reflexividad, simetría y transitividad tanto de la igualdad del monoide concurrente como de la igualdad proposicional, se demuestra que \AgdaFunction{\_F$\approx$\_} es una relación de equivalencia.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{eq}

Luego se define la relación de orden entre habitantes de \AgdaFunction{F} \AgdaBound{S A}, también para un conjunto \AgdaBound{A} arbitrario. En este caso para que (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{a}) sea menor o igual que (\AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{a$'$}), se debe cumplir que \AgdaBound{n} es menor o igual a \AgdaBound{m} según la relación de orden del monoide concurrente y que, al igual que antes, \AgdaBound{a} \AgdaFunction{$\equiv$} \AgdaBound{a$'$}. Una vez más se utilizan las propiedades de la relación de orden del monoide concurrente y las propiedades de la igualdad proposicional para demostrar que \AgdaFunction{\_F$\leq$\_} es un orden parcial respecto de \AgdaFunction{\_F$\approx$\_}.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{orden}

Habiendo definido ambas relaciones, se pasa a definir la estructura monádica. La función \AgdaFunction{return} toma un elemento \AgdaBound{x} de \AgdaBound{A} y lo encapsula en un habitante de \AgdaFunction{F} \AgdaBound{S A}. Esto se realiza generando el par que contiene a \AgdaBound{x} y, en la primera componente, el elemento neutro \AgdaField{zero} del monoide concurrente. El operador \AgdaFunction{bind}, por su lado, toma un elemento (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{a}) de \AgdaFunction{F} \AgdaBound{S A} y una función \AgdaBound{f} de tipo \AgdaBound{A} $\rightarrow$ \AgdaFunction{F} \AgdaBound{S B}, evalúa la función \AgdaBound{f} en el valor de retorno \AgdaBound{a} y luego, a partir del resultado obtenido (\AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{b}), genera un par de tipo \AgdaFunction{F} \AgdaBound{S B} conformado por la suma de \AgdaBound{n} y \AgdaBound{m} (operación del monoide concurrente) y el valor de retorno \AgdaBound{b} obtenido de calcular \AgdaBound{f a}.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{monad}

Para ver que \AgdaFunction{bind} es compatible con la relación de orden definida se debe probar que, dados \AgdaBound{x$_1$} y  \AgdaBound{x$_2$} de tipo \AgdaFunction{F} \AgdaBound{S A} y dos funciones \AgdaBound{f$_1$ f$_2$} $:$ \AgdaBound{A} $\rightarrow$ \AgdaFunction{F} \AgdaBound{S B} tales que se tienen pruebas de que \hbox{\AgdaBound{x$_1$} \AgdaFunction{F$\leq$} \AgdaBound{x$_2$}} y $\forall$ (\AgdaBound{a} $:$ \AgdaBound{A}) $\rightarrow$ \AgdaBound{f$_1$ a} \AgdaFunction{F$\leq$} \AgdaBound{f$_2$ a}, se cumple que \AgdaFunction{bind} \AgdaBound{x$_1$ f$_1$} \AgdaFunction{F$\leq$} \AgdaFunction{bind} \AgdaBound{x$_2$ f$_2$}. Para demostrarlo se realiza \textit{pattern matching} sobre \AgdaBound{x$_1$}, \AgdaBound{x$_2$} y la prueba de que \AgdaBound{x$_1$} \AgdaFunction{F$\leq$} \AgdaBound{x$_2$}. Al hacer esto se unifican las segundas componentes de \AgdaBound{x$_1$} y \AgdaBound{x$_2$} que son iguales. Luego las funciones \AgdaBound{f$_1$} y \AgdaBound{f$_2$} se aplican sobre el mismo valor \AgdaBound{a$_1$} y se puede utilizar el argumento \AgdaBound{f$\leq$}. La prueba \AgdaBound{f$\leq$} aplicada a \AgdaBound{a$_1$} prueba que \AgdaBound{f$_1$ a$_1$} \AgdaFunction{F$\leq$} \AgdaBound{f$_2$ a$_1$}. Su primera componente prueba entonces que (\AgdaField{proj$_1$} (\AgdaBound{f$_1$ a$_1$})) \AgdaField{$\lesssim$} (\AgdaField{proj$_1$} (\AgdaBound{f$_2$ a$_1$})) y su segunda componente demuestra que (\AgdaField{proj$_2$} (\AgdaBound{f$_1$ a$_1$})) \AgdaFunction{$\equiv$} (\AgdaField{proj$_2$} (\AgdaBound{f$_2$ a$_1$})).

\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{bindcomp}

En la primera componente de la prueba de \AgdaFunction{bind-comp} se debe dar un término que demuestre que \AgdaBound{n$_1$} \AgdaField{+} (\AgdaField{proj$_1$} (\AgdaBound{f$_1$ a$_1$})) \AgdaField{$\lesssim$} \AgdaBound{n$_2$} \AgdaField{+} (\AgdaField{proj$_1$} (\AgdaBound{f$_2$ a$_1$})). Para esto se utiliza la compatibilidad de la suma con la relación de orden del monoide concurrente: \AgdaField{scomp$\lesssim$}. Como prueba de que \AgdaBound{n$_1$} \AgdaField{$\lesssim$} \AgdaBound{n$_2$} se utiliza \AgdaBound{fst$\leq$}, que es la primera componenete de la prueba \AgdaBound{x$_1$} \AgdaFunction{F$\leq$} \AgdaBound{x$_2$}. Por otro lado, para mostrar que (\AgdaField{proj$_1$} (\AgdaBound{f$_1$ a$_1$})) \AgdaField{$\lesssim$} (\AgdaField{proj$_1$} (\AgdaBound{f$_2$ a$_1$})) se utiliza la primera componente de la prueba \AgdaBound{f$\leq$} aplicada a \AgdaBound{a$_1$}. Luego, en el lado derecho, hay que probar que (\AgdaField{proj$_2$} (\AgdaBound{f$_1$ a$_1$})) \AgdaFunction{$\equiv$} (\AgdaField{proj$_2$} (\AgdaBound{f$_2$ a$_1$})), para lo cual se utiliza la segunda componente de la prueba \AgdaBound{f$\leq$} aplicada también a \AgdaBound{a$_1$}.

Para probar las leyes de las mónadas se utilizan, a la izquierda, las propiedades análogas correspondientes a la suma del monoide concurrente. Las segundas componentes se prueban trivialmente utilizando la reflexividad de la igualdad proposicional. 
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{monadprops}

Se introduce a continuación la estructura monoidal. Se define el valor \AgdaFunction{unit} únicamente para poder utilizarlo en los tipos de las propiedades que siguen, puesto que este ya está fijo en la formalizacion de mónada concurrente y no se puede modificar. La operación \AgdaFunction{merge}, por su lado, dados dos valores de tipo \AgdaFunction{F} \AgdaBound{S A} y \AgdaFunction{F} \AgdaBound{S B}, debe devolver un valor de tipo \AgdaFunction{F} \AgdaBound{S} (\AgdaBound{A} \AgdaDatatype{$\times$} \AgdaBound{B}). Este se define como el par formado por el máximo de las primeras componentes y el par ordenado de las segundas componentes.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{monoidal}

A la hora de probar la compatibilidad del operador \AgdaFunction{merge} con la relación de orden, se tienen valores \AgdaBound{x$_1$ x$_2$} $:$ \AgdaFunction{F} \AgdaBound{S A} e \AgdaBound{y$_1$ y$_2$} $:$ \AgdaFunction{F} \AgdaBound{S B} tales que \AgdaBound{x$_1$} \AgdaFunction{F$\leq$} \AgdaBound{x$_2$} e \AgdaBound{y$_1$} \AgdaFunction{F$\leq$} \AgdaBound{y$_2$}. Al hacer \textit{pattern matching} sobre todos los valores y también sobre las pruebas, se unifican los valores de retorno de los dos primeros argumentos y de los dos segundos que son iguales debido a las pruebas de desigualdad. 
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{mergecomp}

El objetivo es demostrar, por un lado, que \AgdaField{max} \AgdaBound{n$_1$ m$_1$} \AgdaField{$\lesssim$} \AgdaField{max} \AgdaBound{n$_2$ m$_2$}. Para esto se utiliza la compatibilidad del operador \AgdaField{max} con la relación de orden del monoide concurrente. En el lado derecho, el objetivo es demostrar que (\AgdaBound{a$_1$} \AgdaInductiveConstructor{,} \AgdaBound{b$_1$}) \AgdaFunction{$\equiv$} (\AgdaBound{a$_1$} \AgdaInductiveConstructor{,} \AgdaBound{b$_1$}) puesto que se unificaron los valores. La prueba es, por lo tanto, trivial. 

Las demostraciones de las propiedades del operador \AgdaFunction{merge} también utilizan las propiedades análogas del operador \AgdaField{max}, pero es necesario también utilizar la identidad a derecha de la suma debido a que estas propiedades están definidas utilizando el operador \AgdaFunction{bind} seguido de un \AgdaFunction{return}. Cuando se tiene una expresión del tipo \AgdaFunction{bind} (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{\_}) ($\lambda$ \AgdaBound{\_} $\rightarrow$ \AgdaFunction{return} \AgdaBound{\_}), por definición de \AgdaFunction{return}, es lo mismo que tener \AgdaFunction{bind} (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{\_}) ($\lambda$ \AgdaBound{\_} $\rightarrow$ \AgdaField{zero} \AgdaInductiveConstructor{,} \AgdaBound{\_}). Luego si se aplica la definición de \AgdaFunction{bind} se obtiene: (\AgdaBound{n} \AgdaField{+} \AgdaField{zero} \AgdaInductiveConstructor{,} \AgdaBound{\_}). Por lo tanto, para poder realizar pruebas sobre la primer componente de este resultado es necesario utilizar el lema \AgdaField{+idr} de manera que se pueda reducir la suma con \AgdaField{zero}.

\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{monoidalprops}
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{mergecomm}

Queda por probar únicamente la ley de intercambio. Sean (\AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaBound{a}) de tipo \AgdaFunction{F} \AgdaBound{S A} y (\AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{b}) de tipo \AgdaFunction{F} \AgdaBound{S B}. Luego sean \AgdaBound{f} $:$ \AgdaBound{A} $\rightarrow$ \AgdaFunction{F} \AgdaBound{S C} y \AgdaBound{g} $:$ \AgdaBound{B} $\rightarrow$ \AgdaFunction{F} \AgdaBound{S D} tales que \AgdaBound{f a} $=$ (\AgdaBound{o} \AgdaInductiveConstructor{,} \AgdaBound{c}) y \hbox{\AgdaBound{g b} $=$ (\AgdaBound{p} \AgdaInductiveConstructor{,} \AgdaBound{d})}. Luego, por las definiciones de los operadores \AgdaFunction{bind} y \AgdaFunction{merge}, el objetivo a demostrar en el lado izquierdo es: \AgdaField{max} (\AgdaBound{n} \AgdaField{+} \AgdaBound{o}) (\AgdaBound{m} \AgdaField{+} \AgdaBound{p}) \AgdaField{$\lesssim$} (\AgdaField{max} \AgdaBound{n m}) \AgdaField{+} (\AgdaField{max} \AgdaBound{o p}). Esto se prueba utilizando la ley de intercambio del monoide concurrente. En el lado derecho, se debe demostrar que (\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}) es igual a sí mismo, lo cual se prueba trivialmente. 
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{ichange}

Finalmente, la prueba de que dado un conjunto \AgdaBound{S} que es un monoide concurrente se puede construir una mónada concurrente para el funtor (\AgdaFunction{F} \AgdaBound{S}) queda como se muestra a continuación. Es preciso notar que a cada una de las definiciones dadas se les pasa como argumentos implícitos el conjunto \AgdaBound{S} y la prueba \AgdaBound{cmonoid} que son los parámetros del módulo anónimo donde se encuentran definidas. De esta manera, se utilizan los campos de \AgdaRecord{ConcurrentMonoid} para construir los de \AgdaRecord{ConcurrentMonad}.
\ExecuteMetaData[latex/ConcMonoid-ConcMonad.tex]{proof}
\end{AgdaAlign}

Luego, se puede definir una instancia de \AgdaRecord{ConcurrentMonad} para \AgdaFunction{F} (\AgdaDatatype{Conat $\infty$}) utilizando la prueba recién definida y la instancia \AgdaFunction{conatConcurrent} definida en la sección anterior que prueba que \AgdaDatatype{Conat $\infty$} es un monoide concurrente.
\ExecuteMetaData[latex/Instances/AltConcurrentMonad.tex]{altconcurrent}

Por lo tanto, queda demostrado que la mónada \textit{writer} para el tipo \AgdaDatatype{Conat $\infty$} es una mónada concurrente.   
