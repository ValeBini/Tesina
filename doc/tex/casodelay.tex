\chapter{El caso de la Mónada Delay}\label{chapter:casodelay}

Como se mencionó en el capítulo \ref{chapter:delay}, el tipo \textit{delay} fue introducido por Capretta \cite{capretta:2005} para representar la posible no terminación de programas en la teoría de tipos de Martin-Löf. Sus habitantes son valores ``demorados'', los cuales pueden no terminar nunca. El objetivo de este capítulo es hacer un análisis de este tipo respecto de las estructuras algebraicas previamente definidas. 

Inicialmente se dará la definición de este tipo en Agda, utilizando para ello la notación musical para tipos coinductivos que fue descripta en la sección \ref{coind:agda:musical}. {\color{red} Comentario: agrego un link al repo de donde sacamos esto?} Junto con el tipo se definirán diversas relaciones sobre él, entre las que se encuentran las bisemejanzas débil y fuerte y una relación de orden. 

Una vez introducido el tipo, se demostrará que este tiene estructura de mónada y de funtor monoidal. Para esto se crearán instancias de las estructuras correspondientes para el tipo \textit{delay}. El objetivo final de este capítulo es probar o refutar que el tipo definido tiene estructura de mónada concurrente. La principal dificultad para esto subyace en la prueba de la ley de intercambio, ya que los demás ingredientes están presentes en las pruebas de mónada y funtor monoidal. 

\section{Definición del tipo \textit{delay} con notación musical}\label{casodelay:defmus}

El tipo \textit{delay} se define con notación musical mediante una estructura \AgdaKeyword{data} parametrizada. El parámetro será un conjunto \AgdaBound{A} de tipo \AgdaPrimitiveType{Set}, el cual representa el tipo de los valores de retorno (en caso de que el programa termine). Dado entonces un \AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}, el tipo \AgdaBound{A} \AgdaDatatype{$\bot$} representa el tipo $\mathbf{D}$\AgdaBound{A} definido en la sección \ref{delay:delay}. 

\ExecuteMetaData[latex/Delay.tex]{bottom}

El constructor \AgdaInductiveConstructor{now} toma un valor \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} y genera un valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}. La expresión \AgdaInductiveConstructor{now} \AgdaBound{x} representa un programa que simplemente retorna el valor \AgdaBound{x} sin demoras. 
El constructor \AgdaInductiveConstructor{later} toma un \AgdaBound{x} de tipo \AgdaFunction{$\infty$} (\AgdaBound{A} \AgdaDatatype{$\bot$}), es decir un valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} suspendido o demorado. Que el valor este suspendido o demorado implica que puede ser potencialmente infinito. El constructor \AgdaInductiveConstructor{later} retorna otro valor de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}. Intuitivamente, lo que hace este constructor es ``agregar una demora'' al valor recibido. 

Un habitante del tipo \AgdaBound{A} \AgdaDatatype{$\bot$} puede ser una secuencia finita de constructores \AgdaInductiveConstructor{later} que finalmente retorna un valor \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A}, es decir algo del estilo \AgdaInductiveConstructor{later} (\AgdaFunction{$\sharp$} (\AgdaInductiveConstructor{later} (\AgdaFunction{$\sharp$} ... (\AgdaInductiveConstructor{now} \AgdaBound{x}) ...))); o puede ser una secuencia infinita de constructores \AgdaInductiveConstructor{later} que nunca retorna. Este último es el caso del valor \AgdaFunction{never} que se define a continuación. 

\ExecuteMetaData[latex/Delay.tex]{never}

El tipo \AgdaDatatype{\_$\bot$} viene con dos formas de igualdad (bisemejanza débil y fuerte) y una relación de orden. La bisemejanza fuerte es más fuerte que el orden y, a su vez, este último es más fuerte que la bisemejanza débil. Las tres relaciones se definen utilizando un único tipo \AgdaKeyword{data}, el cual estará indexado por un valor de tipo \AgdaDatatype{Kind} que indica qué tipo de relación es. Este último se define de la siguiente manera:

\ExecuteMetaData[latex/Delay.tex]{kind}

El constructor \AgdaInductiveConstructor{strong} representa la bisemejanza fuerte, mientras que \AgdaInductiveConstructor{other} \AgdaBound{k} representa la relación de orden si \AgdaBound{k} = \AgdaInductiveConstructor{geq}, o la bisemejanza débil si \AgdaBound{k} = \AgdaInductiveConstructor{weak}. La igualdad entre tipos de igualdad, es decir entre valores del tipo \AgdaDatatype{Kind}, es decidible. El operador \AgdaFunction{$\stackrel{?}{=}$-Kind} toma dos tipos de igualdad y decide si son iguales o no, dando a su vez una prueba de ello. 

\ExecuteMetaData[latex/Delay.tex]{deckind} 

Como se puede ver, la definición de esta función es muy sencilla. Para los casos en que ambos tipos son el mismo la prueba es simplemente \AgdaFunction{refl}, y en los casos en que no lo son, la prueba es el patrón absurdo, puesto que no hay manera de dar una prueba de igualdad entre ellos. Esta función sirve para definir un predicado que indica si la relación es de igualdad o no. Este predicado será verdadero para \AgdaInductiveConstructor{strong} y \AgdaInductiveConstructor{other weak}, pero no para \AgdaInductiveConstructor{other geq}. Será de utilidad tener este predicado a la hora de probar que las igualdades son relaciones de equivalencia.

\ExecuteMetaData[latex/Delay.tex]{equality}

Una vez introducido el tipo \AgdaDatatype{Kind}, se definen las relaciones propiamente dichas. Esto se realiza mediante la creación de un módulo llamado \AgdaModule{Equality}, el cual toma como parámetros un conjunto \AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}, que será el tipo de retorno, y una relación \AgdaBound{$\_\sim\_$} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{$\rightarrow$} \AgdaBound{A} \AgdaSymbol{$\rightarrow$} \AgdaPrimitiveType{Set} que establece una noción de igualdad entre valores de tipo \AgdaBound{A}. 

\ExecuteMetaData[latex/Delay.tex]{rel}

Las relaciones se definen a través del tipo \AgdaDatatype{Rel}, el cual toma como parámetro un \AgdaDatatype{Kind} que indica qué tipo de relación es y dos valores de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}, los cuales va a comparar mediante la relación correspondiente. El tipo \AgdaDatatype{Rel} tiene cuatro constructores:
\begin{itemize}[noitemsep]
\item El constructor \AgdaInductiveConstructor{now} indica que, si se tiene una prueba de que dos valores \AgdaBound{x} e \AgdaBound{y} de tipo \AgdaBound{A} están relacionados por la relación \AgdaBound{$\sim$}, es decir que son iguales en \AgdaBound{A}, entonces los términos (\AgdaInductiveConstructor{now} \AgdaBound{x}) y (\AgdaInductiveConstructor{now} \AgdaBound{y}) están relacionados en \AgdaBound{A} \AgdaDatatype{$\bot$} para los tres tipos de relación posibles. Esto está dado por la utilización de la variable \AgdaBound{k} que puede tomar cualquier valor de tipo \AgdaDatatype{Kind} y quiere decir que (\AgdaInductiveConstructor{now} \AgdaBound{x}) y (\AgdaInductiveConstructor{now} \AgdaBound{y}) son bisemejantes tanto débil como fuertemente, y que además (\AgdaInductiveConstructor{now} \AgdaBound{x}) es mayor o igual a (\AgdaInductiveConstructor{now} \AgdaBound{y}).

\item El constructor \AgdaInductiveConstructor{later} también sirve para las tres relaciones. En este caso, los \AgdaBound{x} e \AgdaBound{y} que recibe como parámetros implícitos son de tipo \AgdaFunction{$\infty$} \AgdaBound{A} \AgdaDatatype{$\bot$} (valores de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} posiblemente infinitos). Este constructor pide una prueba (posiblemente infinita) de que (\AgdaField{$\flat$} \AgdaBound{x}) y (\AgdaField{$\flat$} \AgdaBound{y}) están relacionados por la relación \AgdaBound{k} y afirma que entonces (\AgdaInductiveConstructor{later} \AgdaBound{x}) y (\AgdaInductiveConstructor{later} \AgdaBound{y}) están relacionados por la misma relación \AgdaBound{k}.

\item El constructor \AgdaInductiveConstructor{later$^r$} se puede utilizar únicamente para bisemejanza débil. Dados \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} e \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{$\infty$} \AgdaBound{A} \AgdaDatatype{$\bot$} que son parámetros implícitos y una prueba de que \AgdaBound{x} y (\AgdaField{$\flat$} \AgdaBound{y}) son débilmente bisemejantes, este constructor afirma que entonces \AgdaBound{x} y (\AgdaInductiveConstructor{later} \AgdaBound{y}) son débilmente bisemejantes también. Intuitivamente, \AgdaInductiveConstructor{later$^r$} permite agregar un constructor \AgdaInductiveConstructor{later} en el lado derecho de una bisemejanza débil.

\item El constructor \AgdaInductiveConstructor{later$^l$} es análogo a \AgdaInductiveConstructor{later$^r$} e, intuitivamente, permite agregar un constructor \AgdaInductiveConstructor{later} en el lado izquierdo de una relación que, en este caso, puede ser bisemejanza débil o desigualdad. Esto se evidencia en el uso de la variable \AgdaBound{k} que tiene tipo \AgdaDatatype{OtherKind} ya que luego en el tipo de relación que se le pasa a \AgdaDatatype{Rel} se utiliza (\AgdaInductiveConstructor{other} \AgdaBound{k}), quedando claro por qué al definir el tipo \AgdaDatatype{Kind} se separa el tipo \AgdaInductiveConstructor{strong} de los otros dos. 
\end{itemize}

En el uso que permite cada constructor se puede ver que la relación de tipo \AgdaInductiveConstructor{strong} es la más restrictiva, permitiendo únicamente agregar constructores \AgdaInductiveConstructor{later} a ambos lados de la igualdad, mientras que la desigualdad (\AgdaInductiveConstructor{other geq}) es un poco más débil ya que permite también agregar sólo a izquierda y la bisemejanza débil es la más débil de todas ya que permite agregar a ambos lados por separado.

Luego del tipo \AgdaDatatype{Rel} se definen los operadores \AgdaFunction{$\cong$}, \AgdaFunction{$\gtrsim$}, \AgdaFunction{$\lesssim$} y \AgdaFunction{$\approx$}, los cuales representan la bisemejanza fuerte, la desigualdad (mayor o igual), la desigualdad invertida (menor o igual) y la bisemejanza débil, respectivamente. 

\ExecuteMetaData[latex/Delay.tex]{op}

A continuación, se definen otros operadores que tienen que ver con la noción de convergencia introducida en la definición \ref{def:convergencia}. 

\ExecuteMetaData[latex/Delay.tex]{convergencia}

\AgdaBound{x} \AgdaFunction{$\Downarrow$[} \AgdaBound{k} \AgdaFunction{]} \AgdaBound{y} indica que \AgdaBound{x} se relaciona mediante la relación \AgdaBound{k} con (\AgdaInductiveConstructor{now} \AgdaBound{y}). En el caso especial de que la relación sea bisemejanza débil, se escribe \AgdaBound{x} \AgdaFunction{$\Downarrow$} \AgdaBound{y} y se dice que \AgdaBound{x} converge al valor \AgdaBound{y} \AgdaSymbol{:} \AgdaBound{A}. Por otro lado, \AgdaBound{x} \AgdaFunction{$\Downarrow$} indica que la computación \AgdaBound{x} termina, es decir que existe algún valor \AgdaBound{v} tal que \AgdaBound{x} \AgdaFunction{$\Downarrow$} \AgdaBound{v}. Por último, \AgdaBound{x} \AgdaFunction{$\Uparrow$[} \AgdaBound{k} \AgdaFunction{]} indica que \AgdaBound{x} se relaciona con el valor especial \AgdaFunction{never} mediante la relación \AgdaBound{k}. En el caso de que esa relación sea (\AgdaInductiveConstructor{other weak}) se escribe \AgdaBound{x} \AgdaFunction{$\Uparrow$} y se dice que la computación \AgdaBound{x} no termina.

Luego de dar todas las definiciones, se prueba que las tres relaciones son reflexivas y transitivas y que las bisemejanzas son simétricas mientras que la desigualdad es antisimétrica. Antes de poder demostrar esto, se prueba un conjunto de lemas que serán de utilidad para tal propósito. Todas estas pruebas se sitúan dentro de un módulo sin nombre parametrizado con el conjunto \AgdaBound{A} de retorno y su relación de igualdad. Esto se hace para fijar tal conjunto y su relación y poder utilizarlos a lo largo de todas las demostraciones.

\ExecuteMetaData[latex/Delay.tex]{lemas}

El lema \AgdaFunction{$\cong\Rightarrow$} demuestra que todas las relaciones incluyen a la bisemejanza fuerte, es decir que si dos términos \AgdaBound{x y} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} son fuertemente bisemejantes, entonces también son débilmente bisemejantes y, además, \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y}. De manera similar, el segundo lema, \AgdaFunction{$\gtrsim\Rightarrow$}, postula que la desigualdad está incluída en la bisemejanza débil. Si \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y}, entonces \AgdaBound{x} e \AgdaBound{y} son débilmente bisemejantes. Por último, el lema \AgdaFunction{$\Rightarrow\approx$} indica que todas las relaciones están incluídas en la bisemejanza débil. Si \AgdaBound{x} e \AgdaBound{y} se relacionan mediante cualquier tipo de relación \AgdaBound{k}, entonces también se relacionan por la bisemejanza débil. 

Las definiciones que siguen representan las operaciones inversas de los constructores \AgdaInductiveConstructor{later$^r$}, \AgdaInductiveConstructor{later$^l$} y \AgdaInductiveConstructor{later}. Así como estos constructores permiten ``agregar demoras'' a uno y otro lado de las ecuaciones, sus operaciones inversas permiten ``quitar demoras'' para ciertos tipos de relaciones. 

\ExecuteMetaData[latex/Delay.tex]{inversas}

La función \AgdaFunction{later$^{r-1}$} permite sacar un constructor \AgdaInductiveConstructor{later} del lado derecho de una ecuación que tenga como operador a la desigualdad o la bisemejanza débil. Si se tiene \hbox{\AgdaDatatype{Rel} (\AgdaInductiveConstructor{other} \AgdaBound{k}) \AgdaBound{x} (\AgdaInductiveConstructor{later} \AgdaBound{y})}, para algún tipo \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{OtherKind} y algún par de términos \AgdaBound{x} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{$\bot$} e \AgdaBound{y} \AgdaSymbol{:} \AgdaFunction{$\infty$} (\AgdaBound{A} \AgdaDatatype{$\bot$}), entonces se tiene que \AgdaBound{x} se relaciona por el mismo tipo de relación \AgdaBound{k} con (\AgdaField{$\flat$} \AgdaBound{y}). La función \AgdaFunction{later$^{l-1}$}, de manera análoga, permite quitar un constructor \AgdaInductiveConstructor{later} del lado izquierdo de la ecuación, pero sólo para el caso de la bisemejanza débil. Esto implica que si se tiene \AgdaInductiveConstructor{later} \AgdaBound{x} \AgdaFunction{$\approx$} \AgdaBound{y}, entonces también se cumple que \AgdaField{$\flat$} \AgdaBound{x} \AgdaFunction{$\approx$} \AgdaBound{y}. Por último, la función \AgdaFunction{later$^{-1}$} permite quitar el constructor  \AgdaInductiveConstructor{later} de ambos lados de la ecuación. Esto puede realizarse para cualquier tipo de relación \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{Kind}.

Teniendo en cuenta todos estos lemas se pueden probar finalmente las propiedades que cumplen las relaciones definidas. Para poder realizar estas demostraciones se asumen las propiedades análogas para la relación subyacente \AgdaFunction{$\_\sim\_$} sobre el conjunto de retorno \AgdaBound{A}. Se realizan dichas pruebas dentro de un módulo llamado \AgdaModule{Equivalence} que las encapsula para luego importarlas todas juntas cuando sean necesarias. 

\ExecuteMetaData[latex/Delay.tex]{refl}

La reflexividad se prueba para cualquier tipo de relación \AgdaBound{k} \AgdaSymbol{:} \AgdaDatatype{Kind}. Se pide como condición una prueba de que la relación subyacente \AgdaFunction{$\_\sim\_$} es también reflexiva. Tanto la prueba argumento como la prueba que se retorna están dadas por un término de tipo \AgdaFunction{Reflexive} definido en el módulo \href{https://agda.github.io/agda-stdlib/Relation.Binary.Definitions.html}{\AgdaModule{Relation.Binary.Definitions}}. Este es una función que toma una relación binaria \AgdaBound{$\_\sim\_$} y devuelve el tipo correspondiente a la prueba de que dicha relación es reflexiva, es decir $\forall$ \{\AgdaBound{x}\} $\rightarrow$ \AgdaBound{x $\sim$ x}. De manera análoga, la prueba de simetría se da mediante un término de tipo \AgdaFunction{Symmetric} que, dada una relación, devuelve el tipo de la prueba que indica que tal relación es simétrica.

\ExecuteMetaData[latex/Delay.tex]{sym}

La prueba de simetría requiere, además de la prueba de que la relación subyacente \AgdaFunction{$\_\sim\_$} es simétrica, una prueba de que el tipo de relación \AgdaBound{k} : \AgdaDatatype{Kind} es una igualdad. Esta se da mediante el predicado \AgdaFunction{Equality} definido más arriba, que es verdadero para ambas bisemejanzas y falso para la desigualdad. Puede parecer a simple vista que esta prueba no es utilizada para demostrar la simetría. Sin embargo, es la presencia de la misma la que hace que no se requiera analizar el caso (\AgdaInductiveConstructor{later$^l$} \{\AgdaInductiveConstructor{geq}\} \AgdaBound{x$\gtrsim$y}) y la prueba aún así sea exhaustiva. Para verlo más claramente se puede agregar este caso, donde se reemplaza la prueba \AgdaBound{eq} por el patrón absurdo, haciendo que no sea necesario dar la definición correspondiente:
 
\ExecuteMetaData[latex/Delay.tex]{symabs}

La transitividad se prueba, al igual que la reflexividad, para todos los tipos de relación \AgdaBound{k}. Esta demostración es un poco más compleja y requiere de tres pruebas separadas que luego se unen. Es por esta razón que se crea un módulo privado \AgdaModule{Trans} que contenga todas las partes de la prueba dentro, donde luego sólo se exporta públicamente la función \AgdaFunction{trans} que constituye la prueba final. Este módulo toma como parámetro una prueba \AgdaBound{trans-$\sim$} de tipo \AgdaFunction{Transitive} \AgdaBound{$\_\sim\_$} que postula la transitividad de la relación subyacente. 

\ExecuteMetaData[latex/Delay.tex]{trans}

La transitividad postula que, dados tres términos \AgdaBound{x}, \AgdaBound{y} y \AgdaBound{z}, si se tienen las relaciones \AgdaDatatype{Rel} \AgdaBound{k x y} y \AgdaDatatype{Rel} \AgdaBound{k y z}, entonces se debe tener también la relación \AgdaDatatype{Rel} \AgdaBound{k x z}. Para demostrar esto, se necesitan dos pruebas auxiliares: \AgdaFunction{now-trans} que prueba esto asumiendo \AgdaBound{z} $=$ (\AgdaInductiveConstructor{now} \AgdaBound{v}) para algún \AgdaBound{v} $:$ \AgdaBound{A} y \AgdaFunction{later-trans} que hace lo mismo para el caso en que \AgdaBound{z} $=$ (\AgdaInductiveConstructor{later} \AgdaBound{z}). Esta última y la prueba principal \AgdaFunction{trans} son mutuamente recursivas y, por lo tanto, se sitúan dentro de un bloque \AgdaKeyword{mutual}.

Se introduce por último la prueba de antisimetría de la relación de desigualdad. Esta postula que, dados dos términos \AgdaBound{x y} $:$ \AgdaBound{A} \AgdaDatatype{$\bot$}, si se tiene que \AgdaBound{x} \AgdaFunction{$\gtrsim$} \AgdaBound{y} y \AgdaBound{x} \AgdaFunction{$\lesssim$} \AgdaBound{y}, luego \AgdaBound{x} \AgdaFunction{$\cong$} \AgdaBound{y}, es decir que \AgdaBound{x} e \AgdaBound{y} son fuertemente bisemejantes.

\ExecuteMetaData[latex/Delay.tex]{antisym}

Podría darse también la prueba de antisimetría respecto de la bisemejanza débil, pero esta es trivial puesto que, como se indica en el lema \AgdaFunction{$\gtrsim\Rightarrow$}, basta con sólo una de las relaciones de desigualdad para que \AgdaBound{x} e \AgdaBound{y} sean débilmente bisemejantes. Las pruebas de antisimetría en general tienen sentido cuando la igualdad está incluida en la relación de orden, y no al revés.


\section{Prueba de que el tipo \textit{delay} es una mónada}\label{casodelay:monada}

Ya introducido el tipo \textit{delay} en Agda, se procede ahora a dar la prueba de que este tiene estructura de mónada. Esto se realizará mediante la creación de una instancia del \AgdaKeyword{record} \AgdaRecord{Monad} definido en la sección \ref{funtmon:mon}, cuyo parámetro será el funtor \AgdaFunction{\_$\bot$}. La mónada \textit{delay} puede definirse tanto para la bisemejanza fuerte como para la bisemejanza débil. Se detalla a continuación sólo una de estas pruebas puesto que la otra es análoga. 

Lo primero a definir es el operador \textit{bind}, el cual es común a ambas pruebas y se define como sigue:

\ExecuteMetaData[latex/Instances/Monad.tex]{bind}

El operador \AgdaFunction{bind} debe tomar un elemento de tipo $\mathit{M} A$ y una función $A \rightarrow \mathit{M} B$. Como en este caso el funtor $\mathit{M}$ está dado por el operador de tipos \AgdaDatatype{\_$\bot$}, los argumentos de \AgdaFunction{bind} serán un término \AgdaBound{t} de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} y una función \AgdaBound{f} de tipo \AgdaBound{A} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$}. En caso de que el primer argumento esté formado por el un termino (\AgdaInductiveConstructor{now} \AgdaBound{x}), el resultado será simplemente aplicar la función \AgdaBound{f} a \AgdaBound{x}. En caso de que el primer argumento sea algo del estilo (\AgdaInductiveConstructor{later} \AgdaBound{x}), el resultado de aplicar \AgdaFunction{bind} será ``meter'' la aplicación hacia adentro del constructor, de manera que la definición es productiva.

La función \AgdaField{return} estará representada por el constructor \AgdaInductiveConstructor{now}, por lo que no es necesario dar una definición de la misma. Este constructor tiene el comportamiento esperado del operador \AgdaField{return}, cuyo sentido usual es encapsular un valor del tipo de retorno dentro de la mónada.

Una vez definidos los operadores básicos, comienza la prueba propiamente dicha. Se analizará la prueba para la bisemejanza débil, la cual se llevará a cabo dentro de un módulo parametrizado llamado \AgdaModule{Weak} que tendrá dos parámetros: una relación binaria \AgdaBound{$\_\sim\_$} $:$ $\forall$ \{\AgdaBound{A}\} $\rightarrow$ \AgdaBound{A} $\rightarrow$ \AgdaBound{A} $\rightarrow$ \AgdaPrimitiveType{Set} y una prueba de que dicha relación es una relación de equivalencia. El objetivo de estos parámetros es fijar una relación de igualdad para los tipos de retorno. 

\ExecuteMetaData[latex/Instances/Monad.tex]{module}

Se demostrarán a continuación las tres leyes de las mónadas. Estas tres pruebas estarán encapsuladas dentro de otro módulo, en este caso anónimo, en el cual se fijará un tipo de retorno particular \AgdaBound{A} con una relación binaria de igualdad sobre el mismo y una prueba de que dicha relación es reflexiva. Este módulo interno sirve principalmente para agrupar los argumentos comunes que tendrán las demostraciones de las tres leyes dentro de él. 

\ExecuteMetaData[latex/Instances/Monad.tex]{props}

Antes de comenzar a demostrar se abren ciertos módulos del tipo \textit{delay} que serán utilizados en las pruebas. Se abre primero el módulo \AgdaModule{Equality}, pasándole la relación \AgdaBound{$\_\sim\_$} sobre \AgdaBound{A} como argumento y extrayendo del mismo la bisemejanza débil (\AgdaFunction{$\_\approx\_$}). Luego se abre el tipo \AgdaKeyword{data} \AgdaDatatype{Rel} para tener acceso a sus constructores. Finalmente, se abre el módulo \AgdaModule{Equivalence} extrayendo de él la prueba \AgdaFunction{refl} de que todas las relaciones (y en particular la bisemejanza débil) son reflexivas. Con todos estos ingredientes la prueba de la primera ley de mónadas queda como sigue:

\ExecuteMetaData[latex/Instances/Monad.tex]{left-identity}

El tipo de la prueba indica que se demuestra que la función \AgdaField{return}, en este caso el constructor \AgdaInductiveConstructor{now}, es neutro a izquierda de \AgdaFunction{bind}. La demostración es trivial ya que la definición de la función \AgdaFunction{bind} establece la igualdad postulada. Seguidamente se expone la demostración de la segunda ley de mónadas:

\ExecuteMetaData[latex/Instances/Monad.tex]{right-identity} 

En este caso se prueba que el constructor \AgdaInductiveConstructor{now} es neutro a derecha de \AgdaFunction{bind}, es decir que para un término \AgdaBound{t} $:$ \AgdaBound{A} \AgdaDatatype{$\bot$}, \AgdaFunction{bind} \AgdaBound{t} \AgdaInductiveConstructor{now} \AgdaFunction{$\approx$} \AgdaBound{t}. En el caso de que \AgdaBound{t} sea de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), la definición de \AgdaFunction{bind} indica que el resultado del lado izquierdo será la aplicación de \AgdaInductiveConstructor{now} a \AgdaBound{x}, quedando una prueba trivial. En caso de tener algo de la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}), así como la definición de \AgdaFunction{bind} es corecursiva, también lo será la prueba. 

Queda por último la prueba de la tercera ley de mónadas: la asociatividad de \AgdaFunction{bind}. Al igual que en la segunda, el caso base es trivial, mientras que el otro es simplemente corecursivo. 

\ExecuteMetaData[latex/Instances/Monad.tex]{associative} 

Se cierra entonces el módulo anónimo abierto más arriba y se pasa a definir los elementos faltantes para la prueba. La relación de igualdad será, para cualquier conjunto \AgdaBound{A}, la relación de bisemejanza débil \AgdaFunction{$\_\approx\_$} definida en el módulo \AgdaModule{Equality} con la relación subyacente \AgdaBound{$\_\sim\_$}.

\ExecuteMetaData[latex/Instances/Monad.tex]{eq}

La prueba de que la relación establecida es de equivalencia se construye utilizando las demostraciones de reflexividad, simetría y transitividad presentes en el módulo \AgdaModule{Equivalence}, las cuales requieren la propiedad análoga para la relación subyacente. Las pruebas de estas propiedades análogas se extraen de la prueba \AgdaBound{eq$\sim$}. 

\ExecuteMetaData[latex/Instances/Monad.tex]{equivalence}

Finalmente, habiendo definido todos los componentes necesarios, la instancia de \AgdaRecord{Monad} para el tipo \AgdaDatatype{$\_\bot$} queda como sigue:

\ExecuteMetaData[latex/Instances/Monad.tex]{instance}

Se puede observar que a las pruebas de las tres leyes se les pasa como argumento el parámetro requerido por el módulo anónimo en el cual están encapsuladas. 

La versión de la prueba para la bisemejanza fuerte es análoga a la primera, sólo cambiando la relación de igualdad que se utiliza. 

\ExecuteMetaData[latex/Instances/Monad.tex]{strong}


\section{Prueba de que el tipo \textit{delay} es un funtor monoidal}\label{casodelay:monoidal}

En esta sección se dotará al tipo \textit{delay} de la estructura de funtor monoidal. El objetivo es acercarse de a poco a la estructura de mónada concurrente, teniendo ya la estructura monádica, el siguiente paso es la estructura monoidal. El primer elemento a definir es entonces la operación binaria que, para el funtor $\mathit{M}$, debe tener tipo $\mathit{M} A \rightarrow \mathit{M} B \rightarrow \mathit{M} (A \times B)$.  En este caso particular, como el funtor $\mathit{M}$ está dado por el operador de tipos \AgdaDatatype{$\_\bot$}, la operación \AgdaField{merge} tendrá el siguiente tipo: \AgdaBound{A} \AgdaDatatype{$\bot$} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$} $\rightarrow$ (\AgdaBound{A} $\times$ \AgdaBound{B}) \AgdaDatatype{$\bot$}.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{merge}

La función \AgdaFunction{merge} se define mediante \textit{pattern matching} sobre los dos argumentos. En el caso de que ambos sean términos de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), el resultado también será un término de la misma forma, donde el valor de retorno será el par formado por los valores de retorno de los argumentos. Cuando uno de los dos es de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}) y el otro es de la forma (\AgdaInductiveConstructor{later} \AgdaBound{y}), el resultado se construye con un constructor \AgdaInductiveConstructor{later} que dentro tiene una llamada corecursiva suspendida. El término que tenía el constructor \AgdaInductiveConstructor{later} ya no lo tiene, haciendo productiva la corecursión, mientras que el que tenía el constructor \AgdaInductiveConstructor{now} queda igual. En caso de que ambos términos estén formados por un constructor \AgdaInductiveConstructor{later}, también se realiza una llamada corecursiva, donde ambos términos se achican, y por fuera sólo queda un único constructor \AgdaInductiveConstructor{later} en lugar de dos. Esto se debe a que \AgdaFunction{merge}, intuitivamente, representa el paralelismo de dos computaciones, por lo que ambos \AgdaInductiveConstructor{later} se fusionan en uno que realiza internamente el resto de ambas computaciones en paralelo (gracias a la llamada corecursiva de \AgdaFunction{merge}).

El siguiente operador a definir es \AgdaField{fmap}, el cual representa, como se mencionó en la sección \ref{funtmon:funt}, la asignación de morfismos del funtor que en este caso está dado por \AgdaDatatype{$\_\bot$}. Este operador, por lo tanto, asignará, para cada función \AgdaBound{A} $\rightarrow$ \AgdaBound{B}, una función \AgdaBound{A} \AgdaDatatype{$\bot$} $\rightarrow$ \AgdaBound{B} \AgdaDatatype{$\bot$}. 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{fmap}

Dada la función \AgdaBound{f} $:$ \AgdaBound{A} $\rightarrow$ \AgdaBound{B}, si el elemento de tipo \AgdaBound{A} \AgdaDatatype{$\bot$} recibido es de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), entonces el resultado de aplicar \AgdaFunction{fmap} \AgdaBound{f} a tal elemento es un término construído también con \AgdaInductiveConstructor{now}, donde el valor de retorno será la aplicación de \AgdaBound{f} al valor de retorno del argumento. En caso de que el argumento tenga la forma (\AgdaInductiveConstructor{later} \AgdaBound{x}), el resultado de la aplicación de \AgdaFunction{fmap} \AgdaBound{f} a tal término estará formado también por un constructor \AgdaInductiveConstructor{later} que dentro propaga la aplicación de \AgdaFunction{fmap} \AgdaBound{f} al término (\AgdaField{$\flat$} \AgdaBound{x}). 

Queda por definir el operador 0-ario \AgdaField{unit}. Este se definió en la formalización como un elemento de tipo \AgdaBound{M} \AgdaDatatype{$\top$}. En el caso del tipo \textit{delay}, será un habitante del tipo \AgdaDatatype{$\top$ $\bot$}. Se define entonces \AgdaFunction{unit} como el elemento más simple de tal tipo:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{unit}

Definidos estos tres operadores, lo que sigue son las demostraciones de las propiedades. La prueba de que el tipo \textit{delay} es un funtor monoidal puede darse, al igual que la de mónada, tanto para la bisemejanza fuerte como para la débil, sinendo ambas pruebas análogas. Se detalla entonces la versión de la bisemejanza débil. Esta prueba se dará dentro de un módulo llamado \AgdaModule{Weak} que recibirá como parámetro la relación de igualdad subyacente junto con una prueba de que es una relación de equivalencia. 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{module}

La primera propiedad que se demostrará será la asociatividad del operador \AgdaFunction{merge}. Esta se da dentro de un módulo anónimo en el cual se fija como tipo de retorno el producto cartesiano de tres conjuntos \AgdaBound{A}, \AgdaBound{B} y \AgdaBound{C}. Este módulo requiere como parámetro una relación de igualdad entre elementos de este conjunto y la prueba de que la misma es reflexiva. Dentro del módulo se abre, primero, el módulo \AgdaModule{Equality} para el conjunto de retorno \AgdaBound{A} \AgdaDatatype{$\times$} \AgdaBound{B} \AgdaDatatype{$\times$} \AgdaBound{C} con la igualdad subyacente recibida como argumento, del cual se extrae la relación de bisemejanza débil \AgdaFunction{$\_\approx\_$}. Luego se abre el tipo \AgdaDatatype{Rel} de manera que puedan usarse sus constructores sin prefijo. 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{associative}

La prueba no presenta mayores dificultades. En el caso base, donde los tres términos son de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), las aplicación (\AgdaFunction{merge} (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{a}) (\AgdaInductiveConstructor{now} \AgdaBound{b})) (\AgdaInductiveConstructor{now} \AgdaBound{c})) genera el siguiente término: (\AgdaInductiveConstructor{now} ((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c})). Al aplicar \AgdaFunction{fmap} (\AgdaSymbol{$\lambda \{$}((\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}) \AgdaInductiveConstructor{,} \AgdaBound{c})\AgdaSymbol{$\rightarrow$} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))\}) a este resultado, se obtiene el término (\AgdaInductiveConstructor{now} (\AgdaBound{a} \AgdaInductiveConstructor{,} (\AgdaBound{b} \AgdaInductiveConstructor{,} \AgdaBound{c}))), el cual es también el resultado de la aplicación del lado derecho de la ecuación: (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{a}) (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{b}) (\AgdaInductiveConstructor{now} \AgdaBound{c}))), por lo que la prueba queda trivial. En los demás casos, la prueba se resuelve con una llamada corecursiva, donde los términos de la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}) quedan igual, mientras que los que se componen de un constructor \AgdaInductiveConstructor{later} se achican.

Para la prueba del neutro a derecha del operador \AgdaFunction{merge}, se define otro módulo anónimo en el que la relación de igualdad pedida como parámetro y su respectiva prueba de que la relación dada es reflexiva deben estar definidas para elementos del conjunto \AgdaBound{A} \AgdaDatatype{$\times$ $\top$}, para algún conjunto \AgdaBound{A}. Dentro de este módulo se abren también el módulo \AgdaModule{Equality} y el tipo \AgdaDatatype{Rel} para el mismo conjunto.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{rid}

Para el caso en el que \AgdaBound{a} tiene la forma (\AgdaInductiveConstructor{now} \AgdaBound{x}), la aplicación (\AgdaFunction{merge} (\AgdaInductiveConstructor{now} \AgdaBound{x}) \AgdaFunction{unit}) tiene como resultado el término (\AgdaInductiveConstructor{now} (\AgdaBound{x} \AgdaInductiveConstructor{, tt})). Aplicar \AgdaFunction{fmap} (\AgdaSymbol{lambda} \AgdaBound{a} $\rightarrow$ (\AgdaBound{a} \AgdaInductiveConstructor{, tt})) a (\AgdaInductiveConstructor{now} \AgdaBound{x}) tiene el mismo resultado, por lo que la prueba de este caso es trivial. El otro caso se resuelve, al igual, que antes con una llamada corecursiva. 

La prueba del neutro a izquierda de \AgdaFunction{merge} es análoga a la anterior, donde el módulo anónimo en el cual se encapsula es análogo también:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{lid}

Los elementos faltantes son la relación de igualdad para términos de tipo \AgdaBound{A} \AgdaDatatype{$\bot$}, para cualquier conjunto \AgdaBound{A}, y la prueba correspondiente de que tal relación es de equivalencia. La definición de estos elementos es igual a la construída para la estructura de mónada.

\ExecuteMetaData[latex/Instances/Monoidal.tex]{eq}

Finalmente, la instancia de \AgdaRecord{MonoidalFunctor} para el operador de tipos \AgdaDatatype{$\_\bot$} queda como sigue:

\ExecuteMetaData[latex/Instances/Monoidal.tex]{instance}

La estructura de funtor monoidal para la bisemejanza fuerte es análoga a la anterior, quedando como se muestra a continuación: 

\ExecuteMetaData[latex/Instances/Monoidal.tex]{strong}

\section{¿Se puede probar que \textit{delay} es una mónada concurrente?}



\section{Reduciendo el problema a los conaturales}

\subsection{Definición de los conaturales con notación musical}

\subsection{¿Se puede probar que los conaturales forman un monoide concurrente?}

\section{Cambio de paradigma: \textit{sized types}}

\subsection{Definición de los conaturales utilizando \textit{sized types}}

\subsection{Prueba de que los conaturales forman un monoide concurrente}

\subsection{Prueba alternativa de que \textit{delay} es una mónada concurrente}